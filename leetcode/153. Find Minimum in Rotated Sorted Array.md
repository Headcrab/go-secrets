Задача в том, чтобы найти минимальный элемент в отсортированном массиве, который был повернут на неизвестный угол. Например, массив [4,5,6,7,0,1,2] был повернут на 3 элемента вправо. Необходимо найти минимальный элемент, который в данном случае равен 0.

```go
package main

func findMin(nums []int) int {
	left, right := 0, len(nums)-1
	for left < right {
		mid := (left + right) / 2
		if nums[mid] < nums[right] {
			right = mid // !! без минуса, т.к. проверка на правый край
		} else {
			left = mid + 1
		}
	}
	return nums[left]
}

func main() {
	var nums []int
	// Input: nums = [3,4,5,1,2]
	// Output: 1
	// Explanation: The original array was [1,2,3,4,5] rotated 3 times.
	nums = []int{3, 4, 5, 1, 2}
	println(findMin(nums))
	// Input: nums = [4,5,6,7,0,1,2]
	// Output: 0
	// Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
	nums = []int{4, 5, 6, 7, 0, 1, 2}
	println(findMin(nums))
	// Input: nums = [11,13,15,17]
	// Output: 11
	// Explanation: The original array was [11,13,15,17] and it was rotated 4 times.
	nums = []int{11, 13, 15, 17}
	println(findMin(nums))
}
```

Алгоритм решения заключается в использовании бинарного поиска. Мы сравниваем средний элемент с последним элементом. Если средний элемент больше последнего, то минимальный элемент находится в правой половине массива, и мы продолжаем поиск в этой половине. Если средний элемент меньше или равен последнему элементу, то минимальный элемент находится в левой половине массива, и мы продолжаем поиск в этой половине. Мы продолжаем делать это до тех пор, пока не найдем минимальный элемент. Т.е. пока не сойдутся `left` и `right`.

Сложность данного алгоритма составляет `O(log n)`, где `n` - количество элементов в массиве `nums`. Это связано с тем, что в каждой итерации цикла while происходит деление суммы двух соседних элементов на два, что приводит к уменьшению размера диапазона поиска в два раза каждый раз. Таким образом, количество итераций достигает логарифма от размера массива, что дает сложность `O(log n)`.
