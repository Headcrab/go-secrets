Задача в том, чтобы найти максимальный элемент в каждом окне фиксированного размера, которое скользит по массиву целых чисел.

Например, если дан массив `[1,3,-1,-3,5,3,6,7]` и размер окна равен `3`, то результатом будет массив `[3,3,5,5,6,7]`, где каждый элемент - максимальный в своём окне.

- [пример решения в картинках](https://leetcode.com/problems/sliding-window-maximum/solutions/871317/clear-thinking-process-with-picture-brute-force-to-mono-deque-python-java-javascript/)

Алгоритм решения:

- Создаем пустой слайс `res` для хранения максимальных значений в каждом окне.
- Создаем пустой дек (двустороннюю очередь) `d` для хранения индексов элементов в текущем окне.
- Проходим по массиву `nums` и для каждого элемента `i`:
- Удаляем из дека `d` все индексы, которые находятся за пределами текущего окна (т.е. индексы, которые меньше `i-(k-1)`).
- Удаляем из дека `d` все индексы, которые соответствуют элементам, меньшим или равным `nums[i]`.
- Добавляем индекс `i` в конец дека `d`.
- Если индекс первого элемента в деке `d` находится за пределами текущего окна, то удаляем его. (?)
- Если текущий индекс `i` больше или равен `k-1` (т.е. окно уже полностью заполнено), то добавляем максимальный элемент (`nums[q[0]]`) в слайс `res`.
- Возвращаем слайс `res`.

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
	delta := k - 1
	ln := len(nums)
	res := make([]int, 0, ln-delta) // Результирующий массив
	q := make([]int, 0, k)          // Очередь, хранящая индексы элементов
	// Проходим по всем элементам массива
	for i := range nums {
		// Удаляем индексы элементов, которые находятся за пределами текущего окна
		for len(q) > 0 && q[0] < i-delta {
			q = q[1:]
		}
		// Удаляем индексы элементов, которые имеют значения меньшие, чем текущий элемент
		for len(q) > 0 && nums[q[len(q)-1]] <= nums[i] {
			q = q[:len(q)-1]
		}
		// Добавляем индекс текущего элемента в очередь
		q = append(q, i)
		// Если текущее окно полностью находится в массиве, то добавляем максимальный элемент в результирующий массив
		if i >= delta {
			res = append(res, nums[q[0]])
		}
	}
	return res
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```

Алгоритмическая сложность функции `maxSlidingWindow()` - `O(n)`, где `n` - длина массива `nums`, а `k` - размер окна.

---

Функция `maxSlidingWindow` решает задачу нахождения максимального элемента в каждом окне длины `k` в массиве `nums`.

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
	delta := (k - 1)
	result := make([]int, len(nums)-delta)
	d := make([]int, 0, k)
	for i, num := range nums {
		for len(d) > 0 && nums[d[len(d)-1]] < num {
			d = d[:len(d)-1]
		}
		d = append(d, i)
		if i >= delta {
			result[i-delta] = nums[d[0]]
			if d[0] == i-delta {
				d = d[1:]
			}
		}
	}
	return result
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```

Алгоритм использует одну очередь `d`, которая содержит индексы элементов в текущем окне. Очередь `d` хранит индексы элементов в порядке убывания их значений. Таким образом, первый элемент очереди всегда будет максимальным элементом в текущем окне.

Алгоритм проходит по всем элементам массива `nums`. Для каждого элемента `num` алгоритм удаляет из очереди все индексы элементов, которые находятся за пределами текущего окна, и которые, соответственно, не могут быть максимальными элементами в текущем окне. Затем алгоритм удаляет из очереди все индексы элементов, которые имеют значения меньшие, чем текущий элемент `num`, так как эти элементы не могут быть максимальными в текущем окне.

После того, как элемент `num` добавлен в очередь `d`, алгоритм проверяет, находится ли первый элемент очереди `d[0]` в текущем окне. Если да, то `d[0]` является максимальным элементом в окне, и алгоритм добавляет его значение в массив `result`. Если `d[0]` находится за пределами текущего окна, то алгоритм удаляет `d[0]` из очереди, так как это значение больше не может быть максимальным в следующих окнах.

В конце алгоритм возвращает массив `result`, содержащий максимальные элементы в каждом окне длины `k`. Алгоритм имеет сложность `O(n)`, где `n` - длина массива `nums`.

---

Или через абстракцию:

```go
package main

import (
	"fmt"
)

type Deque []int

func NewDeque(capacity int) *Deque {
	d := make(Deque, 0, capacity)
	return &d
}

func (d Deque) Len() int         { return len(d) }
func (d Deque) Front() int       { return d[0] }
func (d Deque) Back() int        { return d[len(d)-1] }
func (d *Deque) PushFront(x int) { *d = append([]int{x}, (*d)...) }
func (d *Deque) PushBack(x int)  { *d = append(*d, x) }
func (d *Deque) RemoveFront()    { *d = (*d)[1:] }
func (d *Deque) RemoveBack()     { *d = (*d)[:len(*d)-1] }

func maxSlidingWindow(nums []int, k int) []int {
	delta := k - 1
	ln := len(nums) - delta
	result := make([]int, ln)
	d := NewDeque(k)
	for r, num := range nums {
		for d.Len() > 0 && nums[d.Back()] < num { // !! for
			d.RemoveBack()
		}
		d.PushBack(r)
		if r >= delta {
			l := r - delta
			result[l] = nums[d.Front()]
			if l == d.Front() {
				d.RemoveFront()
			}
		}
	}
	return result
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```

---

## Идея решения

Дан массив целых чисел `nums`, и скользящее окно размером `k`, которое перемещается из
крайней левой части массива в крайнюю правую. В окне может быть только `k` чисел. При
перемещении вправо в окно приходит одно новое число справа и выпадает одно число слева.

Найти максимум в скользящем окне.

Ограничения:

```
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length
```

Значения идут по неубыванию (т.е `nums[i] <= nums[j]`, `i < j`).
При вставке в `deque` каждое новое значение вытесняет все лежащие в `deque`,
так как оно(значение) всегда больше значения в последнем индексе `deque` (`deque[len(deque)-1]`).

```
nums = [ 1 2 3 4 5 6 7 8 9 10 ]
k = 5

    Window position            Max            Deque
----------------------        -----       -------------
left   right                                  result
 ↓       ↓                                      ↓
[1 2 3 4 5] 6 7 8 9 10          5               5

1 [2 3 4 5 6] 7 8 9 10          6               6

1 2 [3 4 5 6 7] 8 9 10          7               7

1 2 3 [4 5 6 7 8] 9 10          8               8

1 2 3 4 [5 6 7 8 9] 10          9               9

1 2 3 4 5 [6 7 8 9 10]          10              10
```

Значения идут по невозрастанию (т.е `nums[i] >= nums[j]`, `i < j`)
При вставке в `deque` каждое новое значение кладется в конец `deque`,
так как оно(значение) всегда меньше значения в последнем индексе `deque` (`deque[len(deque)-1]`).

```
nums = [ 10 9 8 7 6 5 4 3 2 1 ]
k = 5

    Window position            Max            Deque
----------------------        -----       -------------
left    right                             result
 ↓        ↓                                 ↓
[10 9 8 7 6] 5 4 3 2 1          10          10 9 8 7 6

10 [9 8 7 6 5] 4 3 2 1          9           9 8 7 6 5

10 9 [8 7 6 5 4] 3 2 1          8           8 7 6 5 4

10 9 8 [7 6 5 4 3] 2 1          7           7 6 5 4 3

10 9 8 7 [6 5 4 3 2] 1          6           6 5 4 3 2

10 9 8 7 6 [5 4 3 2 1]          5           5 4 3 2 1
```

Значения лежат в случайном порядке.
Будем действовать так:

- если `deque` пустая прсто положим значение под правым указателем
- если в `deque` есть элементы проверим хвост `deque`:
  - если в последнем индексе `deque` лежит значение больше или равно чем пришедшее в `nums[r]`,
    то кладем его в `deque`
  - если в последнем индексе `deque` лежит значение меньше чем пришедшее в `nums[r]`,
    то извлекаем с конца `deque` по одному элементу, пока значение в конце `deque` меньше `nums[r]`
- когда разница между правым и левым указателем будет равна `k-1`, в результат добавляем значеие из
  начала `deque` (`res = append(res, deque[0])`)
- когда `r-l > k-1`, нужно сдвинуть левый указатель вправо на `1` и проверить что `nums[l] != deque[0]`,
  если они равны то извлеч нулевой элемент `deque`.

```
nums = [ 1 5 3 2 5 4 3 6 8 1 ]
k = 5

    Window position            Max            Deque
----------------------        -----       -------------
left   right                              result
 ↓       ↓                                  ↓
[1 5 3 2 5] 4 3 6 8 1          5            5 5

1 [5 3 2 5 4] 3 6 8 1          5            5 5 4

1 5 [3 2 5 4 3] 6 8 1          5            5 4 3

1 5 3 [2 5 4 3 6] 8 1          6            6

1 5 3 2 [5 4 3 6 8] 1          8            8

1 5 3 2 5 [4 3 6 8 1]          8            8 1
```
