Задача в том, чтобы найти максимальную прибыль, которую можно получить при покупке и продаже акций на рынке, учитывая, что после продажи акций необходимо соблюдать период ожидания (cooldown) перед следующей покупкой.

Constraints: prices.length > 1

Алгоритм решения данной задачи можно разбить на несколько шагов (для dynamic programming):

- Создать массив dp, где dp[i][0] будет представлять максимальную прибыль, которую можно получить на i-ом дне, если не держать акции, а dp[i][1] будет представлять максимальную прибыль, которую можно получить на i-ом дне, если держать акцию.
- Инициализировать dp[0][0] = 0 и dp[0][1] = -prices[0], где prices - массив цен на акции.
- Для каждого дня i от 1 до n-1 (где n - длина массива prices) выполнить следующие действия:
- dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i]) - максимальная прибыль, которую можно получить на i-ом дне, если не держать акции. Это может быть либо максимальная прибыль, которую можно получить на предыдущем дне, если не держать акции, либо максимальная прибыль, которую можно получить на предыдущем дне, если держать акцию и продать ее на i-ом дне.
- dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i]) - максимальная прибыль, которую можно получить на i-ом дне, если держать акцию. Это может быть либо максимальная прибыль, которую можно получить на предыдущем дне, если держать акцию, либо максимальная прибыль, которую можно получить на два дня назад, если не держать акции и купить акцию на i-ом дне.
- Вернуть dp[n-1][0], так как максимальная прибыль, которую можно получить на последнем дне, будет максимальной прибылью за все время.

```go
func maxProfit(prices []int) int {
    n := len(prices)
    if n <= 1 {
        return 0
    }
    // создаем массив dp
    dp := make([][2]int, n)
    // инициализируем dp[0][0] и dp[0][1]
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    for i := 1; i < n; i++ {
        // вычисляем dp[i][0]
        dp[i][0] = max(dp[i-1][0], dp[i-1][1]+prices[i])
        // вычисляем dp[i][1]
        if i == 1 {
            dp[i][1] = max(dp[i-1][1], -prices[i])
        } else {
            dp[i][1] = max(dp[i-1][1], dp[i-2][0]-prices[i])
        }
    }
    // возвращаем максимальную прибыль
    return dp[n-1][0]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

---

Решение через "Greedy Method"

```go
package main

func maxProfit(prices []int) int {
	buy, prevBuy, sell, prevSell := -prices[0], 0, 0, 0
	for _, price := range prices[1:] {
		prevBuy = buy
		buy = max(prevSell-price, prevBuy)
		prevSell = sell
		sell = max(prevBuy+price, prevSell)
	}
	return sell
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func main() {
	var prices []int
	// Input: prices = [1,2,3,0,2]
	// Output: 3
	// Explanation: transactions = [buy, sell, cooldown, buy, sell]
	prices = []int{1, 2, 3, 0, 2}
	println(maxProfit(prices))
	// Input: prices = [1]
	// Output: 0
	prices = []int{1}
	println(maxProfit(prices))
}
```

Здесь `buy` представляет собой максимальную прибыль, которую можно получить, покупая акции, а `sell` - максимальную прибыль, которую можно получить, продавая акции. `prevBuy` и `prevSell` представляют собой предыдущие значения `buy` и `sell`.

Каждый раз, когда мы покупаем акции, мы вычитаем текущую цену акций из предыдущего значения `sell` (т.е. обновляем `buy`), чтобы учесть комиссию и время ожидания (`cooldown`). Каждый раз, когда мы продаем акции, мы добавляем текущую цену акций к предыдущему значению `buy` (т.е. обновляем `sell`), чтобы учесть прибыль.

Использование переменных `prevBuy` и `prevSell` позволяет нам сохранять предыдущие значения `buy` и `sell` перед их обновлением, что необходимо для правильного рассчёта прибыли.

В данном коде `cooldown` не является явным параметром, но он реализуется через `buy` и `sell` переменные. Переменная `buy` представляет собой максимальную прибыль, которую можно получить до совершения предыдущей сделки (buy), а переменная `sell` представляет максимальную прибыль, которую можно получить до совершения предыдущей сделки (sell).

Когда мы покупаем акции, мы вычитаем текущую цену из предыдущей максимальной прибыли, которую можно получить до совершения предыдущей сделки. Как только мы купили акции, мы не можем купить ещё акции в течение следующих двух дней, поэтому переменная `buy` обновляется не позже, чем через два дня (`cooldown`).

Когда мы продаём акции, мы добавляем текущую цену к предыдущей максимальной прибыли, которую можно получить до совершения предыдущей сделки. Продажа акций не влияет на возможность покупки акций, поэтому переменная `sell` обновляется на каждом шаге.

Алгоритмическая сложность функции `maxProfit()` в данном случае составляет `O(n)`, где `n` - количество элементов в массиве `prices`. Это связано с тем, что мы проходим по всем элементам массива только один раз, выполняя постоянное количество операций для каждого элемента. В худшем случае также требуется выполнить `n` операций, что приводит к общей сложности `O(n)`.

---

Использование жадного метода для решения этой задачи может быть менее эффективным, чем динамическое программирование. Тем не менее, мы можем рассмотреть жадный метод для этой задачи.

Идея жадного метода состоит в том, чтобы принимать локально оптимальные решения на каждом шаге и надеяться, что это приведёт к глобально оптимальному решению.

---

Если хочется явный cooldown

```go
func maxProfit(prices []int) int {
	buy, sell, cooldown := -prices[0], 0, 0
	for i := 1; i < len(prices); i++ {
		prevBuy, prevSell := buy, sell
		buy = max(cooldown-prices[i], prevBuy)
		sell = max(prevBuy+prices[i], prevSell)
		cooldown = prevSell
	}
	return sell
}
```

---

Обобщенное решение для всех задач "greedy problems"

```go
func maxProfit(prices []int) int {
	buy, prevSell, sell := -prices[0], 0, 0
	for _, price := range prices[1:] {
		buy = max(buy, prevSell-price)
		prevSell = sell
		sell = max(sell, buy+price)
	}
	return sell
}
```
