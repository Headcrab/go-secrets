Задача в том, чтобы найти максимальную прибыль, которую можно получить при покупке и продаже акций с учётом комиссии за каждую транзакцию. Дан массив цен на акции и фиксированная комиссия за каждую транзакцию. Необходимо найти максимальную прибыль, которую можно было бы получить, совершив несколько транзакций (покупка и продажа считаются за одну транзакцию), при условии, что при продаже акций необходимо учитывать комиссию.

Constraints: prices.length > 1

Алгоритм решения:

- Создаем две переменные: `buy` и `sell`, которые будут хранить максимальную прибыль при покупке и продаже соответственно.
- Инициализируем переменные `buy` и `sell` значением `-prices[0]` и `0` соответственно, так как мы считаем, что покупаем акции в первый день (т.е. покупка считается совершенной если мы можем продать, если не продали считаем что покупки не было).
- Проходим по массиву цен на акции, начиная со второго элемента.
- Для каждой цены находим максимальную прибыль, которую можно получить, совершив транзакцию в этот день.
- Если максимальная прибыль минус комиссия больше, чем текущее значение `buy`, то обновляем значение `buy`.
- Если максимальная прибыль плюс текущая цена минус комиссия больше, чем текущее значение `sell`, то обновляем значение `sell`.
- Возвращаем значение `sell`, которое является максимальной прибылью, которую можно получить при покупке и продаже акций с учетом комиссии за каждую транзакцию.

---

Данный алгоритм решает задачу максимизации прибыли от покупки и продажи акций.

Аргумент `prices` - это массив цен акций в определенные даты. Аргумент `fee` - это комиссия за каждую сделку.

Переменные `buy` и `sell` хранят максимальную прибыль, которую можно получить на данный момент, если последняя операция была покупкой или продажей, соответственно.

В начале алгоритма устанавливаем значение `buy` равным отрицательной стоимости первой акции, так как мы покупаем её. `sell` устанавливаем в `0`, так как мы еще не продавали акции и прибыль равна `0`.

Затем мы перебираем оставшиеся даты и для каждой даты обновляем значения `buy` и `sell`. Для этого мы сравниваем текущее значение `sell` с прибылью, которую мы можем получить, продав акции, купленные по цене `buy` и вычтя комиссию `fee`. Если прибыль больше, чем текущее значение `sell`, то мы обновляем `sell`.

Затем мы сравниваем текущее значение `buy` с прибылью, которую мы можем получить, если продаем акции по текущей цене. Если эта прибыль больше, чем текущее значение `buy`, то мы обновляем `buy`.

В конце алгоритма мы возвращаем значение `sell`, так как на момент последней даты мы должны продать все акции, чтобы получить максимальную прибыль.

```go
package main

func maxProfit(prices []int, fee int) int {
	buy, sell := -prices[0], 0
	for _, price := range prices[1:] {
		sell = max(sell, buy+price-fee)
		// p[1] = 3  max(0, -1+3-2) = 0
		// p[2] = 2  max(0, -1+2-2) = 0
		// p[3] = 8  max(0, -1+8-2) = 5
		// p[4] = 4  max(5, -1+4-2) = 5
		// p[5] = 9  max(5,  1+9-2) = 8
		buy = max(buy, sell-price)
		// p[1] = 3  max(-1, 0-3) = -1
		// p[2] = 2  max(-1, 0-2) = -1
		// p[3] = 8  max(-1, 5-8) = -1
		// p[4] = 4  max(-1, 5-4) =  1
		// p[5] = 9  max(1,  5-9) =  1
	}
	return sell
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main() {
	var prices []int
	// Input: prices = [1,3,2,8,4,9], fee = 2
	// Output: 8
	// Explanation: The maximum profit can be achieved by:
	// - Buying at prices[0] = 1
	// - Selling at prices[3] = 8
	// - Buying at prices[4] = 4
	// - Selling at prices[5] = 9
	// The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
	prices = []int{1, 3, 2, 8, 4, 9}
	println(maxProfit(prices, 2))
	// Input: prices = [1,3,7,5,10,3], fee = 3
	// Output: 6
	prices = []int{1, 3, 7, 5, 10, 3}
	println(maxProfit(prices, 3))
	// Input: prices = [7,1,5], fee = 2
	// Output: 2
	prices = []int{7, 1, 5}
	println(maxProfit(prices, 2))
}
```

Алгоритмическая сложность функции `maxProfit()` равна `O(n)`, где `n` - это количество элементов в списке `prices`.

Это потому, что функция проходит по всем элементам списка `prices` только один раз, выполняя постоянное количество операций для каждого элемента.

Таким образом, время выполнения функции пропорционально количеству элементов в списке, что соответствует `O(n)` времени работы.

---

```go
func maxProfit(prices []int, fee int) int {
	buy, sell := -prices[0], 0
	for _, price := range prices[1:] {
		tmp := buy
		buy = max(buy, sell-price)
		sell = max(sell, tmp+price-fee)
	}
	return sell
}
```

На самом деле "tmp" не нужен, хотя он может облегчить чтение кода.

Если buy не обновляется в день i, то tmp == buy.
Если buy обновляется в день i, то tmp != buy. Обратите внимание, что buy обновляется, потому что мы продаем в день i. Для оптимальной прибыли мы не покупаем в тот же день, а значит, sell остаётся sell.

Я отбрасываю "tmp", и код принимается.

---

Для решения этой задачи с помощью жадного метода мы можем просто покупать акции на каждой дате, когда их цена ниже, чем на предыдущих датах, и продавать их на каждой дате, когда цена выше, чем на предыдущих датах, за вычетом комиссии.

Возможный алгоритм:

- Установить начальное значение `buy` равным первой цене акции.
- Инициализировать `profit` нулём.
- Для каждой даты, начиная со второй:
  - Если текущая цена акции меньше `buy`, то установить `buy` на текущую цену.
  - Если текущая цена акции больше `buy` плюс комиссия, то продать акции, вычислить прибыль и обновить `buy` на текущую цену.
  - Обновить `profit` на текущую прибыль.
- Вернуть `profit`.

```go
package main

func maxProfit(prices []int, fee int) int {
	buy := prices[0]
	profit := 0
	for _, price := range prices[1:] {
		if price < buy {
			buy = price
		} else if price > buy+fee {
			profit += price - buy - fee
			buy = price - fee
		}
	}
	return profit
}

func main() {
	var prices []int
	// Input: prices = [1,3,2,8,4,9], fee = 2
	// Output: 8
	// Explanation: The maximum profit can be achieved by:
	// - Buying at prices[0] = 1
	// - Selling at prices[3] = 8
	// - Buying at prices[4] = 4
	// - Selling at prices[5] = 9
	// The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
	prices = []int{1, 3, 2, 8, 4, 9}
	println(maxProfit(prices, 2))
	// Input: prices = [1,3,7,5,10,3], fee = 3
	// Output: 6
	prices = []int{1, 3, 7, 5, 10, 3}
	println(maxProfit(prices, 3))
	// Input: prices = [7,1,5], fee = 2
	// Output: 2
	prices = []int{7, 1, 5}
	println(maxProfit(prices, 2))
}
```

Здесь мы проходим по всем датам, начиная со второй, и проверяем, нужно ли нам покупать или продавать акции. Если текущая цена акции ниже, чем предыдущая, мы покупаем. Если текущая цена акции выше, чем предыдущая плюс комиссия, мы продаем. В противном случае мы ничего не делаем. В конце мы возвращаем общую прибыль.

```go
package main

func maxProfit(prices []int, fee int) int {
	result := 0
	minPrice := prices[0]
	for _, price := range prices[1:] {
		if minPrice > price {
			minPrice = price
		} else if realPrice := price - fee; realPrice > minPrice {
			result += realPrice - minPrice
			minPrice = realPrice
		}
	}
	return result
}

func main() {
	var prices []int
	// Input: prices = [1,3,2,8,4,9], fee = 2
	// Output: 8
	// Explanation: The maximum profit can be achieved by:
	// - Buying at prices[0] = 1
	// - Selling at prices[3] = 8
	// - Buying at prices[4] = 4
	// - Selling at prices[5] = 9
	// The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
	prices = []int{1, 3, 2, 8, 4, 9}
	println(maxProfit(prices, 2))
	// Input: prices = [1,3,7,5,10,3], fee = 3
	// Output: 6
	prices = []int{1, 3, 7, 5, 10, 3}
	println(maxProfit(prices, 3))
	// Input: prices = [7,1,5], fee = 2
	// Output: 2
	prices = []int{7, 1, 5}
	println(maxProfit(prices, 2))
}
```

Строка `minPrice = realPrice` используется для обновления минимальной цены, которую мы видели до текущей цены, вычитая комиссию за транзакцию, потому что мы всегда хотим покупать по самой низкой возможной цене.
