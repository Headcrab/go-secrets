Дан массив целых чисел, в котором каждое число повторяется дважды, кроме одного числа, которое встречается только один раз. Найдите это число.

```go
package main

func singleNumber(nums []int) int {
	result := 0
	for _, num := range nums {
		result ^= num
	}
	return result
}

func main() {
	var nums []int
	// Input: [2,2,1]
	// Output: 1
	nums = []int{2, 2, 1}
	println(singleNumber(nums))
	// Input: [4,1,2,1,2]
	// Output: 4
	nums = []int{4, 1, 2, 1, 2}
	println(singleNumber(nums))
}
```

В этом решении мы используем операцию XOR (исключающее ИЛИ) для нахождения числа, которое встречается только один раз. Мы начинаем с инициализации переменной `result` в ноль, а затем проходим по всем элементам массива `nums`. Для каждого элемента мы выполняем операцию XOR с `result`. Поскольку операция XOR обладает свойством коммутативности и ассоциативности, то порядок, в котором мы выполняем операцию XOR, не имеет значения.

Если мы применим операцию XOR ко всем элементам массива, то все повторяющиеся числа будут отменены, и останется только число, которое встречается только один раз.

Этот алгоритм работает за `O(n)` времени и `O(1)` по памяти, так как использует только константное количество дополнительной памяти для хранения переменной `result`.

---

Решение через hashmap за O(1) по памяти

Constraints:

- `1 <= nums.length <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`

```go
package main

import "math"

func singleNumber(nums []int) int {
	var m [60001]bool
	for _, num := range nums {
		v := m[num+30000]
		m[num+30000] = !v
	}
	for num, v := range m {
		if v {
			return num - 30000
		}
	}
	panic(0)
}

func main() {
	var nums []int
	// Input: [2,2,1]
	// Output: 1
	nums = []int{2, 2, 1}
	println(singleNumber(nums))
	// Input: [4,1,2,1,2]
	// Output: 4
	nums = []int{4, 1, 2, 1, 2}
	println(singleNumber(nums))
}
```

Это решение через массив, которое может быть рассмотрено как решение через hashmap за `O(1)` по памяти, потому что использует массив фиксированного размера, который имеет постоянный размер `60001` вне зависимости от количества элементов входного массива `nums`.

Объем памяти, который требуется для массива `m`, равен `60001 * size(int)`, что является константой и может быть оценено как `O(1)`.

Таким образом, данное решение использует `O(1)` памяти для массива `m` и является решением за `O(n)` по времени и `O(1)` по памяти в худшем случае.
