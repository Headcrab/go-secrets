Дан массив целых чисел `nums` и целое число `target`. Найдите два таких числа в массиве, которые в сумме дают `target`. Верните их индексы в виде массива.

Мы можем решить эту задачу, используя хэш-таблицу. Мы будем проходить по массиву `nums` и для каждого числа `num` будем проверять, есть ли в хэш-таблице число `target - num`. Если есть, то мы нашли два числа, которые в сумме дают `target`. Возвращаем их индексы.

```go
package main

import "fmt"

func twoSum(nums []int, target int) []int {
	m := make(map[int]int)
	for i, num := range nums {
		complement := target - num
		if j, ok := m[complement]; ok {
			return []int{j, i}
		}
		m[num] = i
	}
	return nil
}

func main() {
	var nums []int
	// Input: nums = [2,7,11,15], target = 9
	// Output: [0,1]
	nums = []int{2, 7, 11, 15}
	fmt.Printf("%v\n", twoSum(nums, 9))
	// Input: nums = [3,2,4], target = 6
	// Output: [1,2]
	nums = []int{3, 2, 4}
	fmt.Printf("%v\n", twoSum(nums, 6))
	// Input: nums = [3,3], target = 6
	// Output: [0,1]
	nums = []int{3, 3}
	fmt.Printf("%v\n", twoSum(nums, 6))
}
```

Мы создали хэш-таблицу `m`, где ключ - число из массива `nums`, а значение - его индекс. Затем мы проходим по массиву `nums` и для каждого числа `num` проверяем, есть ли в хэш-таблице число `target - num`. Если есть, то мы нашли два числа, которые в сумме дают `target`. Возвращаем их индексы в виде массива.

Алгоритмическая сложность функции `twoSum()` - `O(n)`, где `n` - количество элементов в массиве `nums`. Это связано с тем, что алгоритм использует словарь для хранения значений, что позволяет получить доступ к произвольному элементу за `O(1)`, а также проходится только один раз по всем элементам массива.
