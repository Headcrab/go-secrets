#CancellationPatterns #go #patterns #concurrency #context #goroutine #channels #timeout #deadline #cancellation

# Паттерны отмены в Go

```table-of-contents
```

Паттерны отмены в Go являются важной частью разработки конкурентных приложений. Они позволяют корректно завершать горутины и предотвращать утечки ресурсов, когда горутина больше не нужна или когда возникает ошибка. Go предоставляет мощные механизмы для управления отменой, в основном с использованием пакета `context`.

## Контекст (`context`)

Пакет `context` является центральным элементом в управлении отменой в Go. [[Контекст]] предоставляет способ передачи сигналов отмены, крайних сроков (deadlines) и значений через границы API и между процессами. Он позволяет распространять сигнал отмены на все горутины, которые зависят от одного и того же контекста.

Основная идея `context` заключается в том, что он представляет собой дерево контекстов. Каждый контекст может иметь родительский контекст, и при отмене родительского контекста автоматически отменяются все дочерние контексты.

### Создание контекста

Существует несколько способов создания контекста:

1.  `context.Background()`: Возвращает пустой контекст. Он никогда не отменяется, не имеет значений и не имеет крайнего срока. Обычно используется в `main` функции, тестах и как верхний уровень для входящих запросов.

2.  `context.TODO()`: Также возвращает пустой контекст, но используется, когда неясно, какой контекст использовать, или когда он еще не доступен. Это своего рода заглушка, которую следует заменить на более подходящий контекст.

3.  `context.WithCancel(parent Context)`: Возвращает копию родительского контекста с новой функцией отмены. Дочерний контекст может быть отменен вызовом возвращаемой функции `cancel` или при отмене родительского контекста, в зависимости от того, что произойдет раньше.

4.  `context.WithDeadline(parent Context, d time.Time)`: Возвращает копию родительского контекста с крайним сроком, который наступает не позднее, чем время `d`. Дочерний контекст автоматически отменяется по истечении крайнего срока, при вызове возвращаемой функции `cancel` или при отмене родительского контекста, в зависимости от того, что произойдет раньше.

5.  `context.WithTimeout(parent Context, timeout time.Duration)`: Возвращает `context.WithDeadline(parent, time.Now().Add(timeout))`. Удобная функция для установки крайнего срока, который наступает через определенный промежуток времени.

6.  `context.WithValue(parent Context, key, val interface{})`: Возвращает копию родительского контекста, в котором значение `val` связано с ключом `key` и может быть получено с помощью `context.Value(key)`. Используется для передачи данных, связанных с запросом, через границы API.

### Отмена контекста

Отмена контекста происходит при вызове функции `cancel`, возвращаемой функциями `context.WithCancel`, `context.WithDeadline` или `context.WithTimeout`. При отмене контекста все горутины, которые прослушивают этот контекст (или его дочерние контексты), получают сигнал отмены.

### Прослушивание сигнала отмены

Горутины могут прослушивать сигнал отмены через канал `Done()`, который возвращается контекстом. Канал `Done()` закрывается, когда контекст отменяется. Горутины могут использовать оператор `select` для ожидания сигнала отмены вместе с другими операциями.

Пример использования `context.WithCancel`:

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func worker(ctx context.Context, id int) {
	for {
		select {
		case <-ctx.Done():
			fmt.Printf("Worker %d: received cancellation signal\n", id)
			return
		default:
			fmt.Printf("Worker %d: working...\n", id)
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	ctx, cancel := context.WithCancel(context.Background())

	for i := 1; i <= 3; i++ {
		go worker(ctx, i)
	}

	time.Sleep(2 * time.Second)
	fmt.Println("Cancelling all workers...")
	cancel()
	time.Sleep(1 * time.Second) // Даем время воркерам завершиться
}

```

В этом примере создается контекст с функцией отмены. Запускаются три горутины `worker`, каждая из которых в бесконечном цикле проверяет, не был ли отменен контекст. Через 2 секунды вызывается функция `cancel`, которая отправляет сигнал отмены всем горутинам. Горутины получают сигнал через канал `ctx.Done()` и завершают свою работу.

Пример использования `context.WithTimeout`:

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func doSomething(ctx context.Context) {
	select {
	case <-time.After(2 * time.Second):
		fmt.Println("Work done")
	case <-ctx.Done():
		fmt.Println("Context cancelled:", ctx.Err())
	}
}

func main() {
	ctx, cancel := context.WithTimeout(context.Background(), 1*time.Second)
	defer cancel() // Хорошая практика - вызывать cancel даже если контекст отменится по таймауту

	doSomething(ctx)
}
```
В примере создается контекст с таймаутом в 1 секунду. Функция `doSomething` имитирует работу в течение 2 секунд. Поскольку контекст отменяется через 1 секунду, `doSomething` получает сигнал отмены раньше, чем успевает завершить работу.

Пример использования `context.WithDeadline`:

```go
package main

import (
	"context"
	"fmt"
	"time"
)

func doTask(ctx context.Context) {
    select {
    case <-time.After(2 * time.Second):
        fmt.Println("Task completed")
    case <-ctx.Done():
        fmt.Println("Task cancelled:", ctx.Err())
    }
}

func main() {
    deadline := time.Now().Add(1 * time.Second) // Установка крайнего срока через 1 секунду
    ctx, cancel := context.WithDeadline(context.Background(), deadline)
    defer cancel()

    doTask(ctx)
}
```

Этот пример аналогичен примеру с `context.WithTimeout`, но использует `context.WithDeadline` для установки явного времени, когда контекст должен быть отменен.

## Каналы (Channels)

Каналы также могут использоваться для сигнализации об отмене, хотя `context` является более предпочтительным и гибким способом.  Основная идея заключается в использовании закрытия канала как сигнала отмены.

Пример:

```go
package main

import (
	"fmt"
	"time"
)

func worker(cancel <-chan struct{}, id int) {
	for {
		select {
		case <-cancel:
			fmt.Printf("Worker %d: received cancellation signal\n", id)
			return
		default:
			fmt.Printf("Worker %d: working...\n", id)
			time.Sleep(500 * time.Millisecond)
		}
	}
}

func main() {
	cancel := make(chan struct{})

	for i := 1; i <= 3; i++ {
		go worker(cancel, i)
	}

	time.Sleep(2 * time.Second)
	fmt.Println("Cancelling all workers...")
	close(cancel) // Закрытие канала сигнализирует об отмене
	time.Sleep(1 * time.Second)
}
```

В этом примере создается канал `cancel` типа `struct{}`. Пустая структура `struct{}` используется потому, что нам не нужно передавать никаких данных, а только сам факт закрытия канала.  Горутины `worker` прослушивают этот канал. Когда канал закрывается, все горутины, ожидающие чтения из этого канала, немедленно разблокируются и получают нулевое значение типа элемента канала (в данном случае `struct{}{}`). Это служит сигналом отмены.

## Сравнение `context` и каналов для отмены

| Характеристика   | `context`                                                                                             | Каналы                                                                                                 |
| :--------------- | :---------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------- |
| Гибкость         | Более гибкий. Позволяет передавать крайние сроки, значения и иерархически распространять отмену.      | Менее гибкий.  В основном используется только для сигнализации об отмене.                               |
| Распространение | Автоматическое распространение отмены на дочерние контексты.                                           | Требуется явная передача канала всем горутинам, которые нужно отменить.                                |
| Удобство        | Предоставляет стандартный интерфейс для управления отменой в Go.                                     | Может быть проще для понимания в простых случаях, но менее удобен в сложных сценариях.                   |
| Дополнительные возможности | Поддержка крайних сроков и передачи значений.                                                        | Нет дополнительных возможностей, кроме сигнализации об отмене.                                         |
| Рекомендации    | Рекомендуется использовать в большинстве случаев, особенно в сложных приложениях и библиотеках. | Может использоваться в простых случаях, когда достаточно только сигнализации об отмене.                    |

## Вывод

`context` является предпочтительным способом управления отменой в Go. Он предоставляет гибкий и мощный механизм для распространения сигналов отмены, крайних сроков и значений через границы API и между процессами. Каналы также могут использоваться для сигнализации об отмене, но `context` является более удобным и функциональным решением в большинстве случаев. Использование паттернов отмены позволяет создавать надежные и отказоустойчивые приложения, которые корректно реагируют на внешние события и предотвращают утечки ресурсов.

```old
Паттерны отмены
```