#concurrency

#concurrency #programming #multithreading #parallelism #golang #synchronization #race_condition #deadlock #mutex #semaphore

# Конкурентные вычисления

```table-of-contents
```

Конкурентные вычисления - это форма вычислений, в которой несколько вычислений выполняются в течение перекрывающихся периодов времени — *конкурентно* — вместо того, чтобы выполняться *последовательно* (одно завершается до начала следующего). Это свойство системы — будь то программа, компьютер или сеть, — где существует отдельная точка выполнения или "поток управления" для каждого процесса. Конкурентная система — это система, в которой вычисление может продвигаться вперед, не дожидаясь завершения всех остальных вычислений.

Рассмотрим это подробнее, разбив на составные части и предоставив примеры и пояснения.

**1. Конкурентность vs. Параллелизм:**

Важно различать *конкурентность* и *параллелизм*, хотя эти термины часто используются как синонимы.

*   **Конкурентность** — это свойство *структуры* программы/системы. Это означает, что программа разбита на несколько независимых частей (например, горутины в Go, потоки, процессы), которые *могут* выполняться одновременно, но необязательно. Представьте себе жонглёра с несколькими мячами: он работает с ними конкурентно, переключаясь между ними, но в каждый момент времени он держит только один мяч.

*   **Параллелизм** — это свойство *выполнения* программы. Это означает, что несколько частей программы действительно выполняются *одновременно* на разных физических ресурсах (например, на разных ядрах процессора). Это тот же жонглёр, но теперь у него несколько рук, и он может подбрасывать несколько мячей одновременно.

Таким образом, конкурентность — это про то, *как* вы разбиваете задачу, а параллелизм — про то, *как* она выполняется. Программа может быть конкурентной, но не параллельной (например, если она выполняется на одноядерном процессоре).  И наоборот, чисто теоретически, параллелизм возможен и без конкурентности (например, SIMD инструкции), но, как правило, параллельные вычисления структурируются конкурентно.

**2. Преимущества Конкурентности:**

*   **Повышение производительности:** Конкурентность позволяет использовать ресурсы компьютера более эффективно, особенно в системах с несколькими ядрами. Пока одна часть программы ожидает, например, ввода-вывода (чтения с диска, ответа от сети), другая часть может продолжать выполняться.

*   **Улучшение отзывчивости:** В интерактивных приложениях (например, GUI) конкурентность позволяет приложению оставаться отзывчивым на действия пользователя, даже если выполняются длительные операции.

*   **Упрощение моделирования:** Некоторые задачи по своей природе являются конкурентными (например, обработка запросов от нескольких клиентов на сервере). Конкурентное программирование позволяет более естественно моделировать такие задачи.

**3. Сложности Конкурентности:**

Конкурентность вносит дополнительные сложности в программирование:

*   **Состояния гонки (Race Conditions):**  Это ситуация, когда результат выполнения программы зависит от того, в каком порядке выполняются конкурентные части. Это происходит, когда несколько потоков/процессов/горутин обращаются к общим данным без должной синхронизации.
    [[Race Condition]]

*   **Взаимные блокировки (Deadlocks):** Это ситуация, когда два или более конкурентных потока/процесса/горутины блокируют друг друга, ожидая освобождения ресурса, который удерживается другим потоком.
    [[Deadlock]]

*   **Голодание (Starvation):** Это ситуация, когда одному или нескольким конкурентным потокам/процессам/горутинам постоянно не предоставляется доступ к необходимым ресурсам, и они не могут продвигаться вперед.

*   **Сложность отладки:**  Конкурентные программы, как правило, сложнее отлаживать, чем последовательные, из-за недетерминированности выполнения и возможности возникновения трудновоспроизводимых ошибок.

**4. Механизмы Синхронизации:**

Для решения проблем, связанных с конкурентностью, используются различные механизмы синхронизации:

*   **Мьютексы (Mutexes):**  Мьютекс (взаимное исключение) — это примитив синхронизации, который предоставляет эксклюзивный доступ к общему ресурсу. Только один поток/горутина может владеть мьютексом в любой момент времени.
    [[Mutex]]

*   **Семафоры (Semaphores):**  Семафор — это обобщение мьютекса. Он позволяет ограничить количество потоков/горутин, которые могут одновременно получать доступ к ресурсу.
    [[Semaphore]]

*   **Условные переменные (Condition Variables):** Условные переменные позволяют потокам/горутинам ожидать наступления определенного условия, связанного с общим ресурсом.

*   **Каналы (Channels):** Каналы — это механизм, который позволяет горутинам (в Go) безопасно обмениваться данными и синхронизироваться, не прибегая к явным блокировкам.
    [[Channels]]

*   **Атомарные операции (Atomic Operations):** Атомарные операции — это операции, которые выполняются неделимо, то есть они не могут быть прерваны другими потоками/горутинами. Они используются для синхронизации доступа к простым типам данных (например, целым числам).

**5. Пример на Go:**

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

var counter int
var mutex sync.Mutex

func increment(wg *sync.WaitGroup) {
	defer wg.Done()
	for i := 0; i < 1000; i++ {
		mutex.Lock() // Захватываем мьютекс
		counter++
		mutex.Unlock() // Освобождаем мьютекс
	}
}

func main() {
	var wg sync.WaitGroup
	wg.Add(2) // Указываем, что у нас будет 2 горутины

	go increment(&wg) // Запускаем первую горутину
	go increment(&wg) // Запускаем вторую горутину

	wg.Wait() // Ожидаем завершения всех горутин
	fmt.Println("Counter:", counter) // Должно вывести 2000
}
```

В этом примере две горутины пытаются одновременно увеличивать общую переменную `counter`. Без использования мьютекса (`mutex`) возникло бы состояние гонки, и результат был бы непредсказуемым. Мьютекс гарантирует, что только одна горутина может изменять `counter` в любой момент времени. `sync.WaitGroup` используется для ожидания завершения всех горутин.

**6. Разбор примера (по шагам):**

1.  **Объявление переменных:**
    *   `counter`:  Глобальная переменная, которая будет инкрементироваться конкурентно.
    *   `mutex`:  Переменная типа `sync.Mutex`, которая будет использоваться для синхронизации доступа к `counter`.
    *   `wg`:  Переменная типа `sync.WaitGroup`, которая будет использоваться для ожидания завершения горутин.

2.  **Функция `increment`:**
    *   `defer wg.Done()`:  Эта строка гарантирует, что счетчик `wg` будет уменьшен на 1 при выходе из функции, даже если произойдет паника. Это важно для правильной работы `wg.Wait()`.
    *   Цикл `for`:  В цикле происходит 1000 итераций, на каждой из которых переменная `counter` увеличивается на 1.
    *   `mutex.Lock()`:  Перед изменением `counter` горутина пытается захватить мьютекс. Если мьютекс уже захвачен другой горутиной, текущая горутина блокируется и ожидает, пока мьютекс не освободится.
    *   `counter++`:  Увеличение переменной `counter`.
    *   `mutex.Unlock()`:  После изменения `counter` горутина освобождает мьютекс, позволяя другим горутинам получить к нему доступ.

3.  **Функция `main`:**
    *   `wg.Add(2)`:  Увеличивает счетчик `wg` на 2, указывая, что мы будем ожидать завершения двух горутин.
    *   `go increment(&wg)`:  Запускает функцию `increment` в новой горутине.  Ключевое слово `go` создает новую горутину.
    *   `wg.Wait()`:  Блокирует выполнение функции `main` до тех пор, пока счетчик `wg` не станет равным нулю, то есть пока все горутины не завершат свою работу.
    *   `fmt.Println("Counter:", counter)`:  Выводит итоговое значение переменной `counter`.

**7. Альтернативные решения (с плюсами и минусами):**

*   **Использование каналов (Channels):**

    ```go
    package main

    import (
    	"fmt"
    	"sync"
    )

    func increment(ch chan int, wg *sync.WaitGroup) {
    	defer wg.Done()
    	for i := 0; i < 1000; i++ {
    		ch <- 1 // Отправляем 1 в канал
    	}
    }

    func main() {
    	var wg sync.WaitGroup
    	ch := make(chan int) // Создаем канал
    	wg.Add(2)

    	go increment(ch, &wg)
    	go increment(ch, &wg)

    	go func() { // Горутина для агрегации значений из канала
    		wg.Wait()
    		close(ch) // Закрываем канал после завершения всех горутин
    	}()

    	counter := 0
    	for i := range ch { // Читаем из канала, пока он не будет закрыт
    		counter += i
    	}
    	fmt.Println("Counter:", counter)
    }
    ```

    *   **Плюсы:** Более идиоматичный способ для Go, позволяет избежать явных блокировок, упрощает передачу данных между горутинами.
    *   **Минусы:** Может быть немного сложнее для понимания, если вы не знакомы с каналами.  В данном конкретном случае (простое инкрементирование) использование мьютекса, вероятно, будет немного быстрее.

*   **Использование атомарных операций:**

    ```go
    package main

    import (
    	"fmt"
    	"sync"
    	"sync/atomic"
    )

    var counter int64 // Используем int64 для атомарных операций

    func increment(wg *sync.WaitGroup) {
    	defer wg.Done()
    	for i := 0; i < 1000; i++ {
    		atomic.AddInt64(&counter, 1) // Атомарное увеличение
    	}
    }

    func main() {
    	var wg sync.WaitGroup
    	wg.Add(2)

    	go increment(&wg)
    	go increment(&wg)

    	wg.Wait()
    	fmt.Println("Counter:", counter)
    }
    ```

    *   **Плюсы:**  Очень быстро, подходит для простых операций (инкремент, декремент, сравнение и обмен).
    *   **Минусы:**  Подходит только для простых типов данных и операций.  Не может использоваться для сложных операций, требующих нескольких шагов.

**8. Дополнительные примеры и паттерны:**

Существует множество паттернов конкурентного программирования, таких как:

*   **Worker Pools:**  Создается пул горутин (воркеров), которые обрабатывают задачи из общей очереди.  Это позволяет ограничить количество одновременно выполняющихся горутин и избежать перегрузки системы.

*   **Fan-out, Fan-in:**  Fan-out — это когда одна горутина порождает несколько других горутин для выполнения подзадач.  Fan-in — это когда несколько горутин отправляют результаты в один канал.

*   **Pipelines:**  Создается цепочка горутин, каждая из которых выполняет определенную часть обработки данных.  Данные передаются между горутинами по каналам.

* **Context:** Используется `context.Context` для передачи сигналов отмены и крайних сроков выполнения между горутинами.
[[Context]]

**9. Заключение:**

Конкурентные вычисления — это мощный инструмент для повышения производительности, отзывчивости и упрощения моделирования сложных систем. Однако, конкурентность вносит дополнительные сложности в программирование, и требует careful consideration of synchronization mechanisms to avoid race conditions, deadlocks, and other concurrency-related issues. Go предоставляет богатый набор инструментов для конкурентного программирования, включая горутины, каналы, мьютексы, семафоры и атомарные операции. Выбор конкретного инструмента зависит от задачи и требований к производительности и надежности.

```old
Конкурентные вычисления
```