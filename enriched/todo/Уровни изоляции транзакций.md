#TransactionIsolationLevels #database #transactions #ACID #concurrency #isolation #SQL #DBMS #data_consistency #relational_databases

# Уровни изоляции транзакций

```table-of-contents
```

Уровни изоляции транзакций определяют степень, до которой транзакции изолированы друг от друга в многопользовательской среде базы данных.  Это один из ключевых аспектов [[ACID]] свойств (Atomicity, Consistency, Isolation, Durability), гарантирующих надежность и целостность данных.  Более высокий уровень изоляции обеспечивает большую защиту от аномалий, связанных с параллельным выполнением транзакций, но может привести к снижению производительности из-за увеличения блокировок и ожидания ресурсов.  Выбор подходящего уровня изоляции – это компромисс между целостностью данных и производительностью.

## Проблемы параллельного доступа

Когда несколько транзакций обращаются к одним и тем же данным одновременно, могут возникать различные аномалии.  Рассмотрим основные из них:

1.  **Грязное чтение (Dirty Read):**  Транзакция T1 изменяет данные. Транзакция T2 читает эти изменённые данные *до* того, как T1 зафиксирует (commit) изменения.  Если T1 затем откатывается (rollback), T2 остаётся с данными, которых никогда не существовало в стабильном состоянии базы данных.

2.  **Неповторяющееся чтение (Non-Repeatable Read):** Транзакция T1 читает данные.  Транзакция T2 изменяет или удаляет эти данные и фиксирует изменения.  Если T1 повторно читает те же данные, она получает другое значение или не находит их вовсе.

3.  **Фантомное чтение (Phantom Read):**  Транзакция T1 читает набор строк, удовлетворяющих некоторому условию поиска.   Транзакция T2 вставляет новые строки, удовлетворяющие этому же условию, и фиксирует изменения.  Если T1 повторно выполняет тот же запрос, она получает другой набор строк, включающий "фантомные" строки.

4.  **Потерянное обновление (Lost Update):** Две транзакции (Т1 и Т2) читают одни и те же данные, изменяют их и записывают. Изменения первой транзакции (Т1) теряются, потому что вторая транзакция (Т2) перезаписывает их своим значением.

## Стандартные уровни изоляции SQL

Стандарт SQL-92 определяет четыре уровня изоляции, каждый из которых предотвращает определенные аномалии:

1.  **Read Uncommitted (Чтение незафиксированных данных):** Самый низкий уровень изоляции.  Транзакции могут видеть изменения, сделанные другими транзакциями, *до* их фиксации.  Возможны все три аномалии: грязное чтение, неповторяющееся чтение и фантомное чтение. Плюсы данного уровня изоляции в максимальной производительности, минусы в минимальной согласованности данных.

2.  **Read Committed (Чтение зафиксированных данных):**  Транзакции видят только зафиксированные изменения других транзакций.  Предотвращается грязное чтение, но возможны неповторяющееся и фантомное чтения. Это наиболее часто используемый уровень изоляции во многих СУБД по умолчанию (например, в PostgreSQL). Плюсом является большая согласованность, чем Read Uncommitted, минусом — возможность неповторяющегося чтения.

3.  **Repeatable Read (Повторяющееся чтение):**  Транзакция видит "снимок" данных на момент своего начала и не видит изменений, сделанных другими транзакциями, даже если они были зафиксированы после начала данной транзакции. Предотвращаются грязное и неповторяющееся чтения, но возможно фантомное чтение.  В некоторых СУБД (например, MySQL с InnoDB) этот уровень изоляции также предотвращает фантомное чтение, используя блокировки диапазона (gap locks) или next-key locks. Плюсом данного уровня является высокая согласованность данных, минусом может быть снижение производительности при большом количестве параллельных транзакций.

4.  **Serializable (Сериализуемый):**  Самый высокий уровень изоляции.  Транзакции выполняются полностью изолированно, как если бы они выполнялись последовательно, одна за другой.  Предотвращаются все три аномалии: грязное чтение, неповторяющееся чтение и фантомное чтение.  Обычно достигается с помощью строгих блокировок (например, блокировки на уровне таблицы или блокировки диапазона ключей). Плюсом данного уровня является максимальная согласованность, минусом – самая низкая производительность из-за блокировок.

## Реализация уровней изоляции в СУБД

Разные СУБД могут реализовывать уровни изоляции по-разному, используя различные механизмы блокировок и версионности данных.  Например:

*   **Блокировки (Locking):** СУБД может использовать различные типы блокировок (разделяемые, эксклюзивные, блокировки намерений и т.д.) для управления доступом к данным.  Более строгие уровни изоляции обычно требуют более строгих и продолжительных блокировок.

*   **Многоверсионность (Multiversion Concurrency Control, MVCC):**  СУБД хранит несколько версий данных, позволяя транзакциям видеть согласованный "снимок" данных на определенный момент времени.  Это позволяет уменьшить количество блокировок и повысить параллелизм.  PostgreSQL, Oracle, и некоторые другие СУБД используют MVCC.

*   **Snapshot Isolation:** Вариант MVCC, при котором транзакция видит снимок данных на момент её начала. Важно понимать, что Snapshot Isolation в некоторых случаях может приводить к аномалии, называемой **write skew**. Write skew возникает, когда две параллельные транзакции читают пересекающиеся наборы данных, а затем изменяют их таким образом, что если бы они выполнялись последовательно, то одна из них увидела бы изменения, сделанные другой. Это не является фантомным чтением, так как каждая транзакция видит согласованный снимок, но нарушает сериализуемость.

## Пример (Go)

Рассмотрим пример использования уровней изоляции в Go с использованием пакета `database/sql` и драйвера PostgreSQL (`github.com/lib/pq`).

```go
package main

import (
	"database/sql"
	"fmt"
	"log"

	_ "github.com/lib/pq"
)

func main() {
	// Строка подключения к базе данных PostgreSQL
	connStr := "user=postgres password=postgres dbname=testdb sslmode=disable"

	// Открываем соединение с базой данных
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Проверяем соединение
	err = db.Ping()
	if err != nil {
		log.Fatal(err)
	}

	// Функция для выполнения транзакции с заданным уровнем изоляции
	executeTransaction := func(isolationLevel sql.IsolationLevel) {
		// Начинаем транзакцию с указанным уровнем изоляции
		tx, err := db.BeginTx(nil, &sql.TxOptions{Isolation: isolationLevel})
		if err != nil {
			log.Fatal(err)
		}

		// Выполняем какой-либо SQL-запрос внутри транзакции
		_, err = tx.Exec("SELECT * FROM mytable") // Замените на ваш запрос
		if err != nil {
            //Откатывем изменения в случае ошибки
			tx.Rollback()
			log.Fatal(err)
		}
        //Выводим на экран уровень изоляции
        fmt.Println("Transaction with isolation level:", isolationLevel)

		// Фиксируем транзакцию
		err = tx.Commit()
		if err != nil {
			log.Fatal(err)
		}

	}

	// Примеры использования различных уровней изоляции
	executeTransaction(sql.LevelReadUncommitted)
	executeTransaction(sql.LevelReadCommitted)
	executeTransaction(sql.LevelRepeatableRead)
	executeTransaction(sql.LevelSerializable)
    //executeTransaction(sql.LevelSnapshot) // Snapshot Isolation (не поддерживается всеми СУБД и драйверами)
    //executeTransaction(sql.LevelLinearizable) // Linearizable (не поддерживается стандартным SQL)
}
```

В этом примере функция `executeTransaction` принимает уровень изоляции в качестве параметра и выполняет транзакцию с этим уровнем.  Мы используем `db.BeginTx` с `sql.TxOptions`, чтобы указать уровень изоляции.  Обратите внимание, что не все СУБД и драйверы поддерживают все уровни изоляции. Например `sql.LevelSnapshot` и `sql.LevelLinearizable` могут быть недоступны.  В реальном приложении вместо `SELECT * FROM mytable` следует использовать реальные SQL-запросы, соответствующие вашей бизнес-логике. Также важно корректно обрабатывать ошибки и откатывать транзакции в случае сбоев.

## Выбор уровня изоляции

Выбор уровня изоляции зависит от требований приложения к целостности данных и производительности.  Если приложению не критичны редкие аномалии, можно использовать более низкий уровень изоляции (например, Read Committed) для повышения производительности.  Если же требуется максимальная целостность данных, следует использовать Serializable, но при этом нужно быть готовым к возможному снижению производительности.  Во многих случаях Repeatable Read или Read Committed представляют собой хороший компромисс. Важно тщательно протестировать приложение с выбранным уровнем изоляции, чтобы убедиться, что оно работает корректно и не возникает неожиданных проблем.

```old
Уровни изоляции транзакций
```