#FiniteStateMachine #FSM #StateMachine #ComputerScience #Programming #golang #DesignPatterns #SoftwareDesign #Algorithms

# Конечный автомат (FSM)

```table-of-contents
```

## Введение в конечные автоматы

Конечный автомат (КА), или Finite State Machine (FSM), — это математическая модель вычислений, используемая для проектирования как компьютерных программ, так и последовательных логических схем. Он представляет собой абстрактную машину, которая может находиться в одном из конечного числа *состояний*. Автомат находится только в одном состоянии в данный момент времени; это состояние называется *текущим состоянием*. Он может переходить из одного состояния в другое при инициировании *перехода*, вызванного *событием* или *условием*. Конкретный КА определяется списком своих состояний, начальным состоянием и условиями для каждого перехода.

Поведение КА можно наблюдать во многих устройствах современного общества, которые выполняют предопределённую последовательность действий в зависимости от последовательности событий, с которыми они представлены. Простыми примерами являются торговые автоматы, которые выдают продукты, когда введена правильная комбинация монет, лифты, последовательность остановок которых определяется этажами, запрошенными пассажирами, светофоры, которые меняют последовательность при ожидании автомобилей, и кодовые замки, которые требуют ввода комбинации цифр в правильном порядке.

Конечный автомат имеет ограниченную вычислительную мощность. Он может выполнять только очень специфические операции, но его легко реализовать как аппаратно, так и программно. Это делает КА очень полезной моделью для простых систем управления.

## Типы конечных автоматов

Существует два основных типа конечных автоматов:

1.  **Детерминированные конечные автоматы (Deterministic Finite Automaton, DFA):** Для каждого состояния и каждого входного символа существует ровно один переход в следующее состояние.

2.  **Недетерминированные конечные автоматы (Nondeterministic Finite Automaton, NFA):** Для данного состояния и входного символа может существовать несколько возможных следующих состояний, или же переход может не требовать входного символа (эпсилон-переходы).

Несмотря на различия, любой NFA может быть преобразован в эквивалентный DFA, хотя это может привести к экспоненциальному увеличению количества состояний.

## Формальное определение

Формально, детерминированный конечный автомат (DFA) определяется пятеркой $(Q, \Sigma, \delta, q_0, F)$, где:

*   $Q$ — конечное множество состояний.
*   $\Sigma$ — конечный входной алфавит.
*   $\delta: Q \times \Sigma \rightarrow Q$ — функция переходов, которая отображает текущее состояние и входной символ в следующее состояние.
*   $q_0 \in Q$ — начальное состояние.
*   $F \subseteq Q$ — множество конечных (принимающих) состояний.

Недетерминированный конечный автомат (NFA) определяется аналогично, за исключением функции переходов:

$\delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow P(Q)$, где $P(Q)$ - множество всех подмножеств $Q$ (степень множества $Q$).

То есть, функция перехода NFA возвращает *множество* возможных следующих состояний, а также может принимать пустой символ $\epsilon$ (эпсилон), что означает переход без потребления входного символа.

## Пример: Простой выключатель света

Рассмотрим простой выключатель света как конечный автомат. У него есть два состояния: "Включено" (On) и "Выключено" (Off). Входной сигнал — нажатие кнопки.

*   $Q = \{On, Off\}$
*   $\Sigma = \{Press\}$
*   $\delta(Off, Press) = On$
*   $\delta(On, Press) = Off$
*   $q_0 = Off$ (предположим, что свет изначально выключен)
*   $F = \{On, Off\}$ (оба состояния являются допустимыми, в зависимости от задачи, может быть только одно принимающее)

## Реализация конечного автомата на Go

Рассмотрим пример реализации простого конечного автомата, моделирующего поведение турникета. Турникет имеет два состояния: "Заблокирован" (Locked) и "Разблокирован" (Unlocked). События: "Монета" (Coin) и "Проход" (Push).

```go
package main

import "fmt"

// Определяем типы состояний и событий.
type State int
type Event int

const (
	Locked State = iota
	Unlocked
)

const (
	Coin Event = iota
	Push
)

// Структура, представляющая конечный автомат.
type FSM struct {
	currentState State
	transitions  map[State]map[Event]State
}

// Метод для обработки события.
func (fsm *FSM) ProcessEvent(event Event) {
	if nextState, ok := fsm.transitions[fsm.currentState][event]; ok {
		fsm.currentState = nextState
		fmt.Printf("Переход из состояния %v по событию %v в состояние %v\n", fsm.currentState, event, nextState) // Приведение к строке через fmt.Printf неоптимально, нужна отдельная функция
	} else {
		fmt.Printf("Недопустимое событие %v для состояния %v\n", event, fsm.currentState)
	}
}

// Функция для создания нового конечного автомата.
func NewFSM() *FSM {
	transitions := map[State]map[Event]State{
		Locked: {
			Coin: Unlocked,
			Push: Locked,
		},
		Unlocked: {
			Coin: Unlocked,
			Push: Locked,
		},
	}
	return &FSM{currentState: Locked, transitions: transitions}
}

func stateToString(s State) string {
	switch s {
	case Locked:
		return "Locked"
	case Unlocked:
		return "Unlocked"
	default:
		return "Unknown State"
	}
}

func eventToString(e Event) string {
	switch e {
	case Coin:
		return "Coin"
	case Push:
		return "Push"
	default:
		return "Unknown Event"
	}
}

func main() {
	fsm := NewFSM()

	fmt.Printf("Начальное состояние: %v\n", stateToString(fsm.currentState))

	fsm.ProcessEvent(Coin)
	fmt.Printf("Текущее состояние: %v\n", stateToString(fsm.currentState))

	fsm.ProcessEvent(Push)
	fmt.Printf("Текущее состояние: %v\n", stateToString(fsm.currentState))

	fsm.ProcessEvent(Push)
	fmt.Printf("Текущее состояние: %v\n", stateToString(fsm.currentState))

	fsm.ProcessEvent(Coin)
	fmt.Printf("Текущее состояние: %v\n", stateToString(fsm.currentState))
}
```

В этом примере:

1.  Определены типы `State` и `Event` с помощью `iota` для представления состояний и событий.
2.  Структура `FSM` содержит текущее состояние `currentState` и таблицу переходов `transitions`.
3.  Метод `ProcessEvent` обрабатывает событие, изменяя текущее состояние в соответствии с таблицей переходов.
4.  Функция `NewFSM` создает и инициализирует конечный автомат с начальным состоянием "Заблокирован" и определенными переходами.
5. Добавлены функции `stateToString` и `eventToString` для корректного вывода состояний и событий.

Этот код демонстрирует базовую реализацию конечного автомата. Таблицу переходов можно представить как двумерный массив или карту, где ключами являются текущее состояние и событие, а значением — следующее состояние.

## Преимущества и недостатки использования конечных автоматов

**Преимущества:**

*   **Простота и предсказуемость:** КА легко понять и спроектировать, их поведение предсказуемо.
*   **Легкость реализации:** КА легко реализуются как программно, так и аппаратно.
*   **Эффективность:** КА обычно очень эффективны, поскольку они выполняют только предопределенные действия.
*   **Формальная верификация:** Поведение КА может быть формально проверено, что позволяет выявить ошибки на ранних стадиях разработки.

**Недостатки:**

*   **Ограниченная вычислительная мощность:** КА могут выполнять только очень специфические операции.
*   **Проблема "взрыва состояний":** Для сложных систем количество состояний может расти экспоненциально, что затрудняет управление и понимание.
*   **Сложность моделирования асинхронных событий:** КА лучше всего подходят для моделирования систем с синхронными событиями.

## Применение конечных автоматов

Конечные автоматы используются в широком спектре приложений, включая:

*   **Компиляторы и лексические анализаторы:** КА используются для разбора исходного кода и определения лексем.
*   **Регулярные выражения:** Регулярные выражения, используемые для поиска и обработки текста, основаны на конечных автоматах.
*   **Сетевые протоколы:** КА используются для моделирования поведения сетевых протоколов, таких как TCP.
*   **Игровой ИИ:** КА используются для управления поведением неигровых персонажей (NPC) в играх.
*   **Цифровые схемы:** КА используются для проектирования последовательных логических схем.
*   **Системы управления:** КА используются в системах управления, таких как светофоры, лифты и промышленные контроллеры.
*   **Текстовые редакторы:** Для реализации поиска и замены текста.

## Альтернативные подходы и расширения

*   **Иерархические конечные автоматы (Hierarchical State Machines, HSM):** HSM позволяют организовывать состояния в иерархическую структуру, что упрощает управление сложными системами и уменьшает проблему "взрыва состояний".  [[Иерархические конечные автоматы]]
*   **Конечные автоматы с памятью (Pushdown Automata, PDA):** PDA расширяют возможности КА, добавляя стек, что позволяет им распознавать более сложные языки (контекстно-свободные грамматики). [[Конечные автоматы с памятью]]
*   **Машины Тьюринга (Turing Machines):** Машины Тьюринга являются более мощной моделью вычислений, чем КА, и могут выполнять любые алгоритмы. [[Машины Тьюринга]]
* **Statecharts (Диаграммы состояний):** Statecharts - это визуальное расширение конечных автоматов, которое включает в себя иерархию, параллелизм и широковещательную связь. [[Statecharts]]

## Заключение

Конечные автоматы — это мощный и гибкий инструмент для моделирования и реализации систем с дискретными состояниями и переходами. Они широко используются в различных областях компьютерных наук и инженерии благодаря своей простоте, эффективности и предсказуемости. Несмотря на ограничения, КА остаются важной концепцией в информатике и продолжают развиваться в виде различных расширений и альтернативных подходов.

```old
FSM конечные автоматы
```