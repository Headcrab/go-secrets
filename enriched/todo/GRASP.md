#GRASP
#softwareDevelopment #designPatterns #objectOrientedProgramming #SOLID #OOP #responsibilityAssignment #softwareDesign #coupling #cohesion #polymorphism

# GRASP: Принципы распределения обязанностей в объектно-ориентированном проектировании

```table-of-contents
```

GRASP (General Responsibility Assignment Software Patterns/Principles) - это набор принципов, используемых в объектно-ориентированном проектировании для назначения обязанностей классам и объектам. Эти принципы помогают создавать более гибкие, поддерживаемые и повторно используемые системы. GRASP не является строгим набором правил, а скорее рекомендациями, которые следует применять с учетом контекста конкретной задачи.

## Обзор принципов GRASP

GRASP включает в себя девять основных принципов:

1.  **Information Expert (Информационный эксперт)**
2.  **Creator (Создатель)**
3.  **Low Coupling (Слабая связанность)**
4.  **High Cohesion (Высокая связность)**
5.  **Controller (Контроллер)**
6.  **Polymorphism (Полиморфизм)**
7.  **Pure Fabrication (Чистая выдумка)**
8.  **Indirection (Посредник)**
9.  **Protected Variations (Защищенные изменения)**

Рассмотрим каждый из этих принципов подробнее.

### 1. Information Expert (Информационный эксперт)

**Проблема:** Кому следует назначить ответственность за выполнение некоторой обязанности?

**Решение:** Назначьте обязанность тому классу, который обладает всей необходимой информацией для ее выполнения. Этот класс и называется "информационным экспертом".

**Пример:** Предположим, у нас есть система управления заказами. Необходимо рассчитать общую стоимость заказа.  Кто должен отвечать за это? Класс `Order` (Заказ), вероятно, содержит информацию о товарах в заказе и их ценах.  Следовательно, `Order` является информационным экспертом и должен иметь метод `calculateTotal()`.

**Обоснование:** Размещение ответственности у информационного эксперта ведет к более инкапсулированным и, следовательно, более поддерживаемым объектам. Изменения в способе расчета общей стоимости заказа, скорее всего, затронут только класс `Order`.

### 2. Creator (Создатель)

**Проблема:** Кто должен отвечать за создание экземпляров класса?

**Решение:** Назначьте классу B ответственность за создание экземпляров класса A, если выполняется одно или (предпочтительно) несколько из следующих условий:

*   B агрегирует объекты A.
*   B содержит объекты A.
*   B тесно использует объекты A.
*   B записывает экземпляры A.
*   B имеет данные инициализации, которые будут переданы A при создании (B является информационным экспертом по отношению к созданию A).

**Пример:** В системе управления заказами класс `Order` (Заказ) содержит объекты `OrderItem` (Элемент заказа). Следовательно, `Order` является подходящим кандидатом для создания экземпляров `OrderItem`.

**Обоснование:** Принцип Creator способствует низкой связанности ([[Low Coupling]]) между классами. Класс, создающий экземпляры другого класса, естественным образом зависит от него, но эта зависимость оправдана необходимостью создания.

### 3. Low Coupling (Слабая связанность)

**Проблема:** Как поддерживать низкую зависимость между классами?

**Решение:** Назначайте обязанности таким образом, чтобы связанность между классами оставалась минимальной. Связанность - это мера того, насколько сильно один класс полагается на детали реализации другого класса.

**Обоснование:** Низкая связанность ([[Low Coupling]]) упрощает понимание, изменение и повторное использование классов. Изменения в одном классе с меньшей вероятностью повлияют на другие классы. Высокая связанность делает систему жесткой и хрупкой.

**Пример:** Вместо того, чтобы класс `Order` напрямую обращался к базе данных для получения информации о товарах, лучше ввести промежуточный слой (например, репозиторий), который будет отвечать за взаимодействие с базой данных. Это снизит связанность между `Order` и базой данных.

### 4. High Cohesion (Высокая связность)

**Проблема:** Как поддерживать сложность классов на управляемом уровне?

**Решение:** Назначайте обязанности таким образом, чтобы связность класса оставалась высокой. Связность - это мера того, насколько обязанности класса связаны и сфокусированы.

**Обоснование:** Высокая связность ([[High Cohesion]]) означает, что класс выполняет одну четко определенную задачу или набор тесно связанных задач.  Такие классы легче понимать, поддерживать и повторно использовать. Низкая связность означает, что класс выполняет множество несвязанных задач, что делает его сложным и трудным для изменения.

**Пример:** Класс `Order` должен быть сфокусирован на управлении информацией о заказе (товары, клиент, дата и т. д.). Не стоит добавлять в него методы, связанные, например, с отправкой электронной почты или печатью отчетов. Эти обязанности лучше делегировать другим классам.

### 5. Controller (Контроллер)

**Проблема:** Кто должен обрабатывать запросы от пользовательского интерфейса (или других внешних систем)?

**Решение:** Назначьте ответственность за обработку системных событий "контроллеру". Контроллер - это первый объект за пределами уровня пользовательского интерфейса, который получает и координирует (управляет) системную операцию. Контроллер не должен выполнять саму работу, а делегировать ее другим объектам.

**Обоснование:** Использование контроллеров ([[Controller]]) отделяет уровень пользовательского интерфейса от логики приложения, что повышает гибкость и повторное использование. Контроллер действует как посредник между пользовательским интерфейсом и моделью предметной области.

**Пример:** В приложении для обработки заказов контроллер может получать запрос на создание нового заказа. Контроллер может создать экземпляр класса `Order`, добавить в него товары и сохранить заказ в базе данных (делегируя эти задачи другим объектам).

### 6. Polymorphism (Полиморфизм)

**Проблема:** Как обрабатывать альтернативы, основанные на типе? Как создавать подключаемые программные компоненты?

**Решение:** Когда связанные альтернативы или поведение различаются в зависимости от типа (класса), назначайте ответственность за поведение, используя полиморфные операции, каждому типу, для которого поведение различается.

**Обоснование:** Полиморфизм ([[Polymorphism]]) позволяет обрабатывать различные типы объектов единообразным способом. Это упрощает расширение системы новыми типами, не изменяя существующий код.

**Пример:** Предположим, что в системе есть разные способы оплаты (кредитная карта, банковский перевод, электронный кошелек). Вместо использования условных операторов для определения способа оплаты, можно создать интерфейс `PaymentMethod` и реализовать его в классах `CreditCardPayment`, `BankTransferPayment` и `EWalletPayment`. Каждый класс будет иметь свой собственный метод `processPayment()`.

### 7. Pure Fabrication (Чистая выдумка)

**Проблема:** Какому классу следует делегировать ответственность, если вы не хотите нарушать принципы High Cohesion и Low Coupling, но решения, предлагаемые Information Expert, не подходят?

**Решение:** Назначьте ответственность искусственно созданному классу, который не представляет концепцию в предметной области. Этот класс называется "сервисом" в контексте предметно-ориентированного проектирования (Domain-Driven Design).

**Обоснование:** Иногда, чтобы сохранить высокую связность ([[High Cohesion]]) и низкую связанность ([[Low Coupling]]), необходимо ввести класс, который не имеет прямого аналога в предметной области. Это позволяет избежать "раздувания" существующих классов и сохранить их сфокусированными.

**Пример:** Если необходимо отправить уведомление по электронной почте после создания заказа, можно создать класс `EmailService`, который будет отвечать за эту задачу.  `EmailService` не является частью предметной области "управление заказами", но он обеспечивает необходимую функциональность.

### 8. Indirection (Посредник)

**Проблема:** Как назначать обязанности, чтобы избежать прямой связи между двумя (или более) вещами? Как развязать объекты, чтобы поддерживать низкую связанность и повышать потенциал повторного использования?

**Решение:** Назначьте ответственность промежуточному объекту, который будет посредником между другими компонентами или службами, чтобы они не были напрямую связаны.

**Обоснование:** Посредник ([[Indirection]]) снижает связанность между классами, вводя промежуточный слой. Это делает систему более гибкой и устойчивой к изменениям.

**Пример:** Вместо того, чтобы класс `Order` напрямую обращался к классу `Customer` для получения информации о клиенте, можно ввести промежуточный объект `CustomerRepository`, который будет отвечать за получение данных о клиенте.

### 9. Protected Variations (Защищенные изменения)

**Проблема:** Как проектировать объекты, подсистемы и системы так, чтобы изменения или нестабильность в этих элементах не оказывали нежелательного влияния на другие элементы?

**Решение:** Определите точки предсказуемых изменений или нестабильности; назначьте обязанности по созданию стабильного интерфейса вокруг них.

**Обоснование:** Protected Variations ([[Protected Variations]]) защищает элементы системы от изменений в других элементах (объектах, системах, подсистемах), обертывая фокус нестабильности интерфейсом и используя полиморфизм ([[Polymorphism]]) для создания различных реализаций этого интерфейса.

**Пример:** Если система взаимодействует с несколькими внешними платежными системами, можно создать интерфейс `PaymentGateway` и реализовать его для каждой платежной системы (например, `PayPalGateway`, `StripeGateway`). Это защитит систему от изменений в API конкретных платежных систем.

## Заключение

GRASP - это мощный инструмент для проектирования объектно-ориентированных систем. Принципы GRASP помогают распределять обязанности между классами таким образом, чтобы система была гибкой, поддерживаемой и повторно используемой. Важно помнить, что GRASP - это не жесткий набор правил, а руководство, которое следует применять с учетом контекста конкретной задачи.  Принципы GRASP часто используются совместно с другими принципами проектирования, такими как SOLID.

```old
GRASP
```