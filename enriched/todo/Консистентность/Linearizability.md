#Linearizability

#linearizability #consistency #distributed_systems #concurrency #CAP #ACID #go

# Линеаризуемость

```table-of-contents
```

## Введение в линеаризуемость

Линеаризуемость — это свойство [[Консистентность|консистентности]] в [[Распределенные системы|распределенных системах]] и [[Конкурентные вычисления|конкурентных вычислениях]]. Оно гарантирует, что каждая операция над общими данными выглядит так, как будто она выполняется атомарно в какой-то определенный момент времени между ее вызовом и завершением. Это сильная гарантия консистентности, упрощающая рассуждения о поведении системы.

## Детальное описание линеаризуемости

Линеаризуемость — это локальное свойство. Это означает, что система является линеаризуемой, если каждый объект в этой системе линеаризуем. Под объектом понимается некоторая абстракция данных, например, регистр, очередь, стек и т.д. В [[Конкурентные вычисления|конкурентных вычислениях]] или [[Распределенные системы|распределенных системах]] несколько потоков или процессов могут одновременно обращаться к одному и тому же объекту. Линеаризуемость гарантирует, что несмотря на параллельное выполнение, история выполнения операций над объектом эквивалентна некоторой последовательной истории, где операции упорядочены в соответствии с реальным временем.

### Сравнение с последовательной консистентностью

Важно отличать линеаризуемость от [[Sequential Consistency|последовательной консистентности]]. [[Sequential Consistency]] требует, чтобы результат любого выполнения был таким же, как если бы операции всех процессов выполнялись в некотором последовательном порядке, и операции каждого отдельного процесса отображались в этом порядке в том порядке, в котором они были выданы этим процессом. Линеаризуемость добавляет к этому требованию упорядочивания по реальному времени. То есть, если операция A завершилась до того, как началась операция B, то в последовательном порядке A должна предшествовать B.

### Формальное определение

Формально, линеаризуемость определяется следующим образом:

История выполнения H называется линеаризуемой, если существует такая последовательная история S, что:

1.  S содержит те же операции, что и H.
2.  S сохраняет порядок программы (program order) из H.
3.  Если операция op1 завершается до начала операции op2 в H, то op1 предшествует op2 в S.

### Пример

Рассмотрим два процесса, P1 и P2, работающих с общим регистром R, изначально равным 0.

*   P1 вызывает write(R, 1).
*   P2 вызывает write(R, 2).
*   P1 получает подтверждение о завершении write(R, 1).
*   P2 получает подтверждение о завершении write(R, 2).
*   P1 вызывает read(R) и получает 2.

В линеаризуемой системе такая история возможна. Последовательная история, эквивалентная данной: write(R, 2), write(R, 1), read(R). Однако, если бы P1 получил подтверждение о завершении write(R, 1) *до* того, как P2 вызвал write(R, 2), то единственной возможной последовательной историей была бы write(R, 1), write(R, 2), read(R), и read(R) должен был бы вернуть 1.

### Реализация линеаризуемости

Реализация линеаризуемости обычно требует использования механизмов синхронизации, таких как блокировки, семафоры или атомарные операции. В [[Распределенные системы|распределенных системах]] линеаризуемость может быть достигнута с помощью протоколов консенсуса, таких как Paxos или Raft. Линеаризуемость может быть дорогостоящей с точки зрения производительности, поскольку она требует строгого упорядочивания операций.

## Пример реализации линеаризуемого регистра на Go

Рассмотрим реализацию линеаризуемого регистра с использованием мьютекса в Go.

```go
package main

import (
	"fmt"
	"sync"
)

// LinearizableRegister представляет собой линеаризуемый регистр.
type LinearizableRegister struct {
	value int
	mu    sync.Mutex
}

// NewLinearizableRegister создает новый линеаризуемый регистр.
func NewLinearizableRegister(initialValue int) *LinearizableRegister {
	return &LinearizableRegister{value: initialValue}
}

// Read читает значение из регистра.
func (r *LinearizableRegister) Read() int {
	r.mu.Lock()
	defer r.mu.Unlock()
	return r.value
}

// Write записывает значение в регистр.
func (r *LinearizableRegister) Write(newValue int) {
	r.mu.Lock()
	defer r.mu.Unlock()
	r.value = newValue
}

func main() {
	reg := NewLinearizableRegister(0)

	var wg sync.WaitGroup
	wg.Add(2)

	// Поток 1
	go func() {
		defer wg.Done()
		reg.Write(1)
		fmt.Println("Поток 1: Записано 1")
		val := reg.Read()
		fmt.Println("Поток 1: Прочитано", val)
	}()

	// Поток 2
	go func() {
		defer wg.Done()
		reg.Write(2)
		fmt.Println("Поток 2: Записано 2")
		val := reg.Read()
		fmt.Println("Поток 2: Прочитано", val)
	}()

	wg.Wait()
}
```

В этом примере `LinearizableRegister` использует мьютекс (`sync.Mutex`) для обеспечения эксклюзивного доступа к значению регистра (`value`). Операции `Read` и `Write` блокируют мьютекс перед доступом к значению и разблокируют его после. Это гарантирует, что операции выполняются атомарно и упорядочены в соответствии с реальным временем.

### Объяснение примера

1.  **Структура `LinearizableRegister`**: Определяет регистр, содержащий целочисленное значение (`value`) и мьютекс (`mu`) для синхронизации доступа.

2.  **Функция `NewLinearizableRegister`**: Конструктор, создающий новый регистр с начальным значением.

3.  **Методы `Read` и `Write`**:
    *   Оба метода используют `r.mu.Lock()` в начале для захвата мьютекса, гарантируя, что только один поток может выполнять операцию чтения или записи в любой момент времени.
    *   `defer r.mu.Unlock()` гарантирует, что мьютекс будет разблокирован при выходе из функции, даже если произойдет паника.
    *   `Read` возвращает текущее значение регистра.
    *   `Write` устанавливает новое значение регистра.

4.  **Функция `main`**:
    *   Создает экземпляр `LinearizableRegister`.
    *   Использует `sync.WaitGroup` для ожидания завершения обоих горутин.
    *   Две горутины параллельно выполняют операции записи и чтения над регистром.

Вывод программы может варьироваться, но всегда будет соответствовать линеаризуемой истории. Например, один из возможных выводов:

```
Поток 1: Записано 1
Поток 2: Записано 2
Поток 1: Прочитано 2
Поток 2: Прочитано 2
```

Или:

```
Поток 2: Записано 2
Поток 1: Записано 1
Поток 2: Прочитано 1
Поток 1: Прочитано 1
```

В обоих случаях, если чтение происходит после записи, оно видит записанное значение.  Порядок записи может меняться, но чтения всегда консистентны.

## Преимущества и недостатки линеаризуемости

**Преимущества:**

*   **Простота рассуждений:** Линеаризуемость упрощает понимание и анализ поведения [[конкурентных]] и [[распределенных систем]]. Она предоставляет сильную гарантию консистентности, которая близка к интуитивному пониманию последовательного выполнения.
*   **Компонуемость:** Линеаризуемые объекты могут быть скомпонованы для создания более сложных линеаризуемых систем.

**Недостатки:**

*   **Производительность:** Линеаризуемость может быть дорогостоящей с точки зрения производительности, особенно в [[распределенных системах]]. Строгое упорядочивание операций может привести к задержкам и снижению пропускной способности.
*   **Доступность:** В некоторых случаях линеаризуемость может быть недостижима без ущерба для доступности системы, как следует из [[CAP-теорема|CAP-теоремы]].

## Альтернативы линеаризуемости

Существуют и другие модели консистентности, более слабые, чем линеаризуемость, которые могут предложить лучшую производительность или доступность. К ним относятся:

*   **Последовательная консистентность ([[Sequential Consistency]]):**  Не требует упорядочивания операций по реальному времени.
*   **Консистентность по причинно-следственной связи ([[Causal Consistency]]):**  Гарантирует, что причинно связанные операции упорядочены, но не требует упорядочивания несвязанных операций.
*   **Консистентность в конечном счете ([[Eventual Consistency]]):**  Гарантирует, что в конечном итоге все реплики придут к одному и тому же значению, но не предоставляет никаких гарантий относительно порядка операций или времени, необходимого для достижения консистентности.
*   **Консистентность чтения своих записей ([[Read-your-writes Consistency]]):** Гарантирует, что процесс всегда увидит свои собственные записи.
*   **Монотонная согласованность чтения ([[Monotonic Read Consistency]]):**  Если процесс прочитал определенное значение, все последующие чтения будут возвращать это значение или более новое.
*   **Монотонная согласованность записи ([[Monotonic Write Consistency]]):** Гарантирует, что записи одного и того же процесса будут применены в том порядке, в котором они были выданы.

Выбор подходящей модели консистентности зависит от конкретных требований приложения.

## Заключение

Линеаризуемость — это мощная гарантия консистентности, которая упрощает рассуждения о [[конкурентных]] и [[распределенных системах]]. Однако она может быть дорогостоящей с точки зрения производительности и доступности. При проектировании системы важно тщательно взвесить преимущества и недостатки линеаризуемости и рассмотреть альтернативные модели консистентности, которые могут лучше соответствовать требованиям приложения.

```old
Linearizability
```