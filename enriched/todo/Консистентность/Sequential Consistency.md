#sequentialConsistency #consistency #distributedSystems #memoryModels #concurrency #programming #computerScience #parallelism #sharedMemory #linearizability

# Последовательная консистентность (Sequential Consistency)

```table-of-contents
```

## Общее описание

Последовательная консистентность является одной из моделей [[консистентности]], используемых в области параллельных вычислений, в частности, в распределенных системах и системах с общей памятью. Она предоставляет программистам интуитивно понятную модель выполнения, облегчая рассуждения о корректности параллельных программ.

## Формальное определение

Определение последовательной консистентности, данное Лесли Лэмпортом в его статье 1979 года "How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs", звучит следующим образом:

> "...результат любого выполнения такой же, как если бы операции всех процессоров выполнялись в некотором последовательном порядке, и операции каждого отдельного процессора появляются в этой последовательности в том порядке, в котором они были заданы программой."

Это определение можно разбить на две основные части:

1.  **Глобальный порядок:** Все операции (чтения и записи) от всех процессоров могут быть упорядочены в единую глобальную последовательность. Это означает, что существует гипотетический "единый поток", в котором выполняются все операции, сохраняя видимый эффект для всех процессоров.

2.  **Программный порядок:** Операции, выполняемые каждым отдельным процессором, появляются в глобальном порядке в том же порядке, в котором они указаны в программе этого процессора. Это правило, по сути, сохраняет причинно-следственные связи внутри каждого потока выполнения.

## Пояснение на примере

Представим себе систему с двумя процессорами (P1 и P2) и двумя общими переменными (x и y), изначально равными 0.

**Процессор P1:**

```
x = 1
print(y)
```

**Процессор P2:**

```
y = 1
print(x)
```
Рассмотрим несколько возможных сценариев выполнения и их соответствие последовательной консистентности:

**Сценарий 1 (Последовательно консистентный):**

1.  P1: x = 1
2.  P1: print(y) // Выводит 0
3.  P2: y = 1
4.  P2: print(x) // Выводит 1

Этот сценарий последовательно консистентен. Существует глобальный порядок операций, который соответствует порядку выполнения в программе каждого процессора.

**Сценарий 2 (Последовательно консистентный):**

1.  P2: y = 1
2.  P2: print(x) // Выводит 0
3.  P1: x = 1
4.  P1: print(y) // Выводит 1

Этот сценарий также последовательно консистентен, несмотря на то, что процессоры выполняют операции в другом порядке. Главное, что *существует* такой глобальный порядок, который удовлетворяет обоим условиям.

**Сценарий 3 (Не последовательно консистентный):**

Допустим, что P1 вывел 1, а P2 вывел 1. То есть:
*   P1: print(y) // Выводит 1
*   P2: print(x) // Выводит 1

Такой результат *не* является последовательно консистентным. Невозможно построить глобальный порядок операций, который бы соответствовал программному порядку и приводил к такому результату. Если P1 увидел, что y = 1, значит, операция `y = 1` процессора P2 должна была произойти *до* `print(y)` процессора P1. Аналогично, если P2 увидел, что x = 1, значит, операция `x = 1` процессора P1 должна была произойти *до* `print(x)` процессора P2.  Это приводит к циклической зависимости, которую невозможно разрешить в рамках последовательного порядка.

## Сравнение с другими моделями консистентности

Последовательная консистентность является более строгой моделью, чем, например, [[слабая консистентность]] (Weak Consistency) или [[консистентность освобождения]] (Release Consistency). Эти модели допускают большую степень свободы в переупорядочивании операций, что может повысить производительность, но усложняет программирование.

С другой стороны, последовательная консистентность менее строгая, чем линеаризуемость ([[Linearizability]]). Линеаризуемость требует, чтобы каждая операция выглядела так, как будто она выполняется атомарно в некоторой точке между своим вызовом и завершением. Последовательная консистентность не накладывает таких ограничений на временные рамки выполнения операций.

## Реализация последовательной консистентности

Реализация последовательной консистентности в реальных системах может быть дорогостоящей с точки зрения производительности. Для обеспечения глобального порядка операций часто требуются механизмы синхронизации, такие как блокировки или барьеры памяти, которые могут замедлять выполнение программы.

Существуют различные оптимизации и техники для смягчения влияния на производительность, такие как:

*   **Спекулятивное выполнение:** Процессоры могут выполнять операции вне очереди, предполагая определенный порядок доступа к памяти. Если предположение оказывается неверным, результаты спекулятивного выполнения отбрасываются, и операции выполняются заново в правильном порядке.
*   **Оптимизации компилятора:** Компиляторы могут анализировать код и переупорядочивать операции, сохраняя при этом семантику последовательной консистентности.
*  **Аппаратная поддержка:** Некоторые архитектуры процессоров предоставляют аппаратные механизмы для обеспечения последовательной консистентности, такие как когерентные кэши и протоколы когерентности.

## Пример реализации на Go

```go
package main

import (
	"fmt"
	"runtime"
	"sync"
)

// Имитация общей памяти.
var (
	x, y int
	wg   sync.WaitGroup
	mu   sync.Mutex // Мьютекс для обеспечения последовательной консистентности.
)

func p1() {
	defer wg.Done()

	mu.Lock() // Захватываем мьютекс перед записью в общую память.
	x = 1
	mu.Unlock() // Освобождаем мьютекс после записи.

	mu.Lock() // Захватываем мьютекс перед чтением из общей памяти.
    fmt.Printf("P1: y = %d\n", y)
	mu.Unlock() // Освобождаем мьютекс.
}

func p2() {
	defer wg.Done()
	mu.Lock() // Захватываем мьютекс перед записью.
	y = 1
	mu.Unlock() // Освобождаем мьютекс.

	mu.Lock() // Захватываем мьютекс.
	fmt.Printf("P2: x = %d\n", x)
	mu.Unlock() // Освобождаем мьютекс.
}

func main() {
	runtime.GOMAXPROCS(2) // Используем два процессорных ядра.
	wg.Add(2)
	go p1()
	go p2()
	wg.Wait()
	fmt.Println("Final values: x =", x, ", y =", y)
}
```

В этом примере используется мьютекс (`sync.Mutex`) для обеспечения последовательной консистентности. Перед каждой операцией чтения или записи в общую память (переменные `x` и `y`) поток захватывает мьютекс, а после операции – освобождает. Это гарантирует, что операции выполняются атомарно и в некотором последовательном порядке, предотвращая гонки данных и обеспечивая последовательно консистентное поведение.

**Важно отметить:** Использование мьютекса в данном случае – это простой способ продемонстрировать реализацию последовательной консистентности. В реальных приложениях, где производительность критична, могут использоваться более тонкие механизмы синхронизации или альтернативные модели консистентности, которые предлагают компромисс между простотой программирования и эффективностью.

## Преимущества и недостатки

**Преимущества:**

*   **Простота программирования:** Последовательная консистентность предоставляет интуитивно понятную модель выполнения, облегчая рассуждения о корректности параллельных программ.
*   **Предсказуемость:** Результаты выполнения программы предсказуемы и соответствуют ожиданиям, основанным на последовательном выполнении операций.

**Недостатки:**

*   **Производительность:** Реализация последовательной консистентности может быть дорогостоящей с точки зрения производительности из-за необходимости использования механизмов синхронизации.
*   **Ограниченная масштабируемость:** В системах с большим количеством процессоров обеспечение глобального порядка операций может стать узким местом, ограничивая масштабируемость.

## Заключение

Последовательная консистентность – это важная модель консистентности, которая обеспечивает баланс между простотой программирования и производительностью. Она широко используется в системах с общей памятью и распределенных системах, где важна предсказуемость и корректность выполнения параллельных программ. Однако, при проектировании высокопроизводительных систем, следует учитывать потенциальные издержки, связанные с реализацией последовательной консистентности, и рассматривать альтернативные модели консистентности, которые могут предложить более оптимальный компромисс между простотой и эффективностью.

```old
[[Последовательная консистентность]] (Sequential Consistency)
```