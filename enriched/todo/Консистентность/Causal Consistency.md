#causalConsistency #consistency #distributedSystems #databases #CAPtheorem #transactions #ordering #concurrency #replication

# Причинно-Следственная Консистентность

```table-of-contents
```

## Введение в Причинно-Следственную Консистентность

Причинно-следственная консистентность ([[Causal Consistency]]) — это одна из моделей консистентности, используемых в распределенных системах и базах данных. Она слабее, чем последовательная консистентность ([[Sequential Consistency]]), но сильнее, чем консистентность в конечном счёте ([[Eventual Consistency]]). Она гарантирует, что если одна операция *логически* предшествует другой (то есть, существует причинно-следственная связь), то все узлы системы увидят эти операции в том же порядке. Операции, не связанные причинно-следственными связями, могут быть видны в разном порядке на разных узлах.

## Определение Причинно-Следственной Связи

Причинно-следственная связь между операциями определяется отношением "произошло до" ([[Happened-Before Relation]]). Это отношение, предложенное Лесли Лэмпортом, формализует интуитивное понятие о том, что одно событие может повлиять на другое.

Отношение "произошло до" (обозначается →) определяется следующими правилами:

1.  **Внутрипроцессное упорядочение:** Если события *a* и *b* происходят в одном и том же процессе, и *a* происходит перед *b* в программном порядке, то *a* → *b*.
2.  **Отправка-получение сообщений:** Если событие *a* - это отправка сообщения, а событие *b* - получение этого же сообщения, то *a* → *b*.
3.  **Транзитивность:** Если *a* → *b* и *b* → *c*, то *a* → *c*.

Другими словами, если событие *a* могло потенциально повлиять на событие *b*, то *a* → *b*.

## Примеры Причинно-Следственной Консистентности

Рассмотрим пример с социальной сетью.

1.  **Пользователь A** публикует сообщение "Привет!".
2.  **Пользователь B**, увидев сообщение пользователя A, отвечает: "Привет, A!".
3.  **Пользователь C** видит оба сообщения.

В системе с причинно-следственной консистентностью, если пользователь C видит ответ пользователя B, он *обязательно* увидит и исходное сообщение пользователя A, потому что ответ B причинно-следственно зависит от сообщения A (B увидел сообщение A, прежде чем ответить).

Однако, если два пользователя одновременно публикуют несвязанные сообщения, разные пользователи могут увидеть эти сообщения в разном порядке. Например:

1.  **Пользователь A** публикует сообщение "Погода хорошая".
2.  **Пользователь B** публикует сообщение "Пойду гулять".

Пользователь C может увидеть сначала сообщение B, а потом A, а пользователь D - наоборот. Это допустимо, потому что сообщения A и B не связаны причинно-следственно.

## Реализация Причинно-Следственной Консистентности

Существует несколько способов реализации причинно-следственной консистентности. Один из распространенных подходов — использование векторных часов ([[Vector Clocks]]).

**Векторные часы** — это механизм, позволяющий отслеживать причинно-следственные связи между событиями в распределенной системе. Каждый процесс в системе поддерживает вектор, где *i*-й элемент вектора представляет собой счетчик событий *i*-го процесса.

При выполнении операции процесс увеличивает свой собственный счетчик в векторе. При отправке сообщения процесс включает в него свой текущий векторный час. При получении сообщения процесс обновляет свой векторный час, беря покомпонентный максимум своего текущего вектора и вектора, полученного с сообщением.

Сравнивая векторные часы двух событий, можно определить, существует ли между ними причинно-следственная связь:

*   Если векторный час *a* меньше или равен векторному часу *b* по всем компонентам, то *a* → *b*.
*   Если векторный час *a* больше векторного часа *b* хотя бы по одной компоненте, и меньше хотя бы по одной другой компоненте, то события *a* и *b* параллельны (не связаны причинно-следственно).

В распределенной базе данных векторные часы могут использоваться для определения порядка применения операций. Если операция *a* → *b*, то все узлы базы данных должны применить операцию *a* до операции *b*.

## Преимущества и Недостатки Причинно-Следственной Консистентности

**Преимущества:**

*   **Более сильная консистентность, чем eventual consistency:** Гарантирует, что причинно-связанные операции будут видны в правильном порядке.
*   **Более высокая доступность и производительность, чем sequential consistency:** Позволяет параллельно выполнять несвязанные операции, что уменьшает задержки и увеличивает пропускную способность.
*   **Интуитивно понятная модель:** Легче понять и использовать, чем более слабые модели консистентности.

**Недостатки:**

*   **Сложнее в реализации, чем eventual consistency:** Требуется механизм отслеживания причинно-следственных связей, например, векторные часы.
*   **Слабее, чем sequential consistency:** Не гарантирует единого глобального порядка всех операций.
*   Может быть недостаточно строгой для некоторых приложений, которым требуется полная сериализуемость операций.

## Сравнение с Другими Моделями Консистентности

| Модель консистентности                                                                | Описание                                                                                                                                                                      | Пример                                                                                                                                                                               |
| :------------------------------------------------------------------------------------ | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Строгая консистентность ([[Strict Consistency]])**                                  | Все операции видны всем узлам мгновенно и в одном и том же порядке. Это самая сильная модель, но практически нереализуемая в распределенных системах.                         | Чтение переменной сразу после ее записи другим процессом всегда возвращает записанное значение.                                                                                      |
| **Последовательная консистентность ([[Sequential Consistency]])**                     | Все узлы видят операции в одном и том же порядке, но этот порядок не обязательно соответствует реальному времени. Операции одного процесса выполняются в программном порядке. | Если процесс A записал значение 1, а затем процесс B записал значение 2, то все процессы увидят сначала запись 1, а затем запись 2.                                                  |
| **Причинно-следственная консистентность ([[Causal Consistency]])**                    | Если операция A причинно-следственно предшествует операции B, то все узлы увидят A перед B. Несвязанные операции могут быть видны в разном порядке.                           | Если пользователь A опубликовал сообщение, а пользователь B ответил на него, то все пользователи, увидевшие ответ B, обязательно увидят и исходное сообщение A.                      |
| **Консистентность в конечном счёте ([[Eventual Consistency]])**                       | Если в систему не поступает новых обновлений, то со временем все узлы придут к одному и тому же состоянию. Порядок операций не гарантируется.                                 | Если пользователь A изменил свой профиль, то со временем все пользователи увидят эти изменения, но в какой-то момент времени разные пользователи могут видеть разные версии профиля. |
| **Консистентность чтения своих записей ([[Read-your-writes Consistency]])**           | Гарантия того что пользователь всегда увидит свои собственные изменения.                                                                                                      | Если пользователь обновил свой пост, он гарантированно при следующей загрузке страницы увидит обновленную версию.                                                                    |
| **Консистентность монотонного чтения ([[Monotonic Read Consistency]])**               | Если пользователь прочитал определенное значение, все последующие чтения этого пользователя вернут это же или более новое значение.                                           | Если пользователь увидел 10 комментариев к посту, то при следующей загрузке он увидит не менее 10 комментариев (возможно, больше, если появились новые).                             |
| **Консистентность монотонной записи ([[Monotonic Write Consistency]])**               | Гарантия того, что записи одного и того же пользователя будут применены в том порядке, в котором они были сделаны.                                                            | Если пользователь сначала изменил имя, а затем аватар, то система гарантированно применит эти изменения в том же порядке.                                                            |
| **Консистентность "Запись следует за чтением" ([[Writes-Follow-Reads Consistency]])** | Гарантия того, что если пользователь прочитал определенное значение, то все его последующие записи будут видны после этого чтения.                                            | Пользователь читает статью. Затем он пишет комментарий к этой статье. Гарантируется, что его комментарий будет виден после прочтения статьи.                                         |
## Пример Реализации на Go

```go
package main

import (
	"fmt"
	"sync"
)

// VectorClock представляет собой векторный час.
type VectorClock map[string]int

// NewVectorClock создает новый векторный час.
func NewVectorClock() VectorClock {
	return make(VectorClock)
}

// Increment увеличивает счетчик процесса в векторном часе.
func (vc VectorClock) Increment(process string) {
	vc[process]++
}

// Merge объединяет два векторных часа, выбирая покомпонентный максимум.
func (vc VectorClock) Merge(other VectorClock) {
	for process, count := range other {
		if vc[process] < count {
			vc[process] = count
		}
	}
}

// Compare сравнивает два векторных часа и возвращает отношение "произошло до".
//  -1: this < other (this happened-before other)
//   0: this == other (concurrent)
//   1: this > other (other happened-before this)
//  -2: the two vector clocks are incomparable.
func (vc VectorClock) Compare(other VectorClock) int {
    thisLessThanOther := false
    thisGreaterThanOther := false

    allKeys := make(map[string]bool)
    for k := range vc {
        allKeys[k] = true
    }
    for k := range other {
        allKeys[k] = true
    }

    for key := range allKeys {
        if vc[key] < other[key] {
            thisLessThanOther = true
        } else if vc[key] > other[key] {
            thisGreaterThanOther = true
        }
    }

    if thisLessThanOther && thisGreaterThanOther {
        return -2 // Incomparable
    } else if thisLessThanOther {
        return -1 // this < other
    } else if thisGreaterThanOther {
        return 1 // this > other
    } else {
        return 0 // this == other
    }
}

// Event представляет собой событие в распределенной системе.
type Event struct {
	Process string
	Data    string
	Clock   VectorClock
}

// DistributedSystem представляет собой упрощенную модель распределенной системы.
type DistributedSystem struct {
	Processes map[string][]Event
	mu        sync.Mutex
}

// NewDistributedSystem создает новую распределенную систему.
func NewDistributedSystem(processes []string) *DistributedSystem {
	ds := &DistributedSystem{
		Processes: make(map[string][]Event),
	}
	for _, process := range processes {
		ds.Processes[process] = []Event{}
	}
	return ds
}

// AddEvent добавляет событие в систему.
func (ds *DistributedSystem) AddEvent(process string, data string, clock VectorClock) {
	ds.mu.Lock()
	defer ds.mu.Unlock()

	ds.Processes[process] = append(ds.Processes[process], Event{
		Process: process,
		Data:    data,
		Clock:   clock,
	})
}

// GetEvents возвращает события для данного процесса.
func (ds *DistributedSystem) GetEvents(process string) []Event {
	ds.mu.Lock()
	defer ds.mu.Unlock()

	return ds.Processes[process]
}

// CausalOrder возвращает события в причинно-следственном порядке.
func (ds *DistributedSystem) CausalOrder() []Event {
	ds.mu.Lock()
	defer ds.mu.Unlock()

	var orderedEvents []Event
	remainingEvents := make(map[int]Event) // Используем map для быстрого доступа по индексу
    nextIndex := 0

	// Сначала добавляем все события в remainingEvents.
    for _, events := range ds.Processes {
        for _, event := range events {
            remainingEvents[nextIndex] = event
            nextIndex++
        }
    }

	for len(remainingEvents) > 0 {
		found := false
		for i := 0; i< nextIndex; i++ {
			event, ok := remainingEvents[i]
            if !ok {
                continue // Событие уже было добавлено
            }
            canAdd := true
            for j := 0; j < nextIndex; j++ {
                otherEvent, okOther := remainingEvents[j]
				if !okOther || i == j {
					continue
				}

				comparisonResult := otherEvent.Clock.Compare(event.Clock)
				if comparisonResult == -1 { // otherEvent happened-before event

					canAdd = false
                    break
				}
			}

			if canAdd {
                orderedEvents = append(orderedEvents, event)
                delete(remainingEvents, i) // Удаляем событие из remainingEvents.
				found = true
            }

        }
        if !found { // deadlock detection, shouldn't happen with correct vector clock usage.
             fmt.Println("Deadlock detected! Remaining events:")
                for _, event := range remainingEvents {
                    fmt.Printf("  Process: %s, Data: %s, Clock: %v\n", event.Process, event.Data, event.Clock)
                }
                panic("Deadlock in causal ordering")
        }

	}

	return orderedEvents
}

func main() {
	// Создаем распределенную систему с тремя процессами.
	processes := []string{"A", "B", "C"}
	ds := NewDistributedSystem(processes)

	// Процесс A создает событие 1.
	clockA1 := NewVectorClock()
	clockA1.Increment("A")
	ds.AddEvent("A", "Event 1", clockA1)

	// Процесс B создает событие 2, получив информацию о событии 1 от A.
	clockB2 := NewVectorClock()
	clockB2.Merge(clockA1)
	clockB2.Increment("B")
	ds.AddEvent("B", "Event 2", clockB2)

	// Процесс C создает событие 3.
	clockC3 := NewVectorClock()
	clockC3.Increment("C")
	ds.AddEvent("C", "Event 3", clockC3)

  // Процесс А, получив информацию о С3, создает событие 4
    clockA4 := NewVectorClock()
    clockA4.Merge(clockC3)
    clockA4.Increment("A")
    ds.AddEvent("A", "Event 4", clockA4)

	// Получаем события в причинно-следственном порядке.
	orderedEvents := ds.CausalOrder()

	// Выводим события.
	fmt.Println("Events in causal order:")
	for _, event := range orderedEvents {
		fmt.Printf("  Process: %s, Data: %s, Clock: %v\n", event.Process, event.Data, event.Clock)
	}
}
```

Этот пример демонстрирует базовую реализацию причинно-следственной консистентности с использованием векторных часов. Векторные часы позволяют отслеживать причинно-следственные связи между событиями, а функция `CausalOrder` обеспечивает упорядочивание событий в соответствии с этими связями.

## Заключение

Причинно-следственная консистентность — это компромисс между строгостью консистентности и производительностью/доступностью. Она предоставляет более сильные гарантии, чем консистентность в конечном счёте, сохраняя при этом возможность параллельного выполнения несвязанных операций. Эта модель консистентности подходит для многих распределенных приложений, где важна целостность данных, но не требуется полная сериализуемость всех операций.

```old
[[Консистентность по причинно-следственной связи]] (Causal Consistency)
```